// <auto-generated>
// Generated file. DO NOT EDIT!
// Generated from schema 'FirstProject' [0xC0D233E6]
// File created by coherence-code-generator 
// Generated at time 2020-08-27T09:16:51Z
// </auto-generated>



#region Shared
// -----------------------------------
//  Shared.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using System;
    using System.Collections.Generic;
	using Replication.Client.Unity.Ecs;


	

static class TypeIds
{

	public const uint InternalWorldPositionComponent = 0;

	public const uint InternalLocalUser = 1;

	public const uint InternalWorldPositionQuery = 2;

	public const uint InternalCoherenceSessionComponent = 3;

}


enum TypeEnums
{

	InternalWorldPositionComponent = 0,

	InternalLocalUser = 1,

	InternalWorldPositionQuery = 2,

	InternalCoherenceSessionComponent = 3,

}


internal static class InternalGlobalLookups
{
	internal readonly static Dictionary<Type, TypeEnums> GlobalTypeToEnumLookup = new Dictionary<Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		GlobalTypeToEnumLookup.Add(typeof(T), e);
	}
}

internal static class GlobalLookups
{
	internal readonly static Dictionary<System.Type, TypeEnums> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

internal static class GlobalTypeIdLookups
{
	internal readonly static Dictionary<System.Type, uint> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, uint>();

	internal static uint Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static (uint, bool) LookupUsingType(System.Type t)
	{
		var foundIt = GlobalTypeToEnumLookup.TryGetValue(t, out var value);
		return !foundIt ? ((uint, bool)) (0, foundIt) : (value, true);
	}

	internal static void Register<T>(uint e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

class GlobalTypeIdLookupsWrapper : ITypeIdLookups
{
	public (uint, bool) LookupUsingType(Type t)
	{
		return GlobalTypeIdLookups.LookupUsingType(t);
	}
}

static class RleConstants
{
	public const uint EndOfComponentArray = 255;
	public const uint EndOfComponentIndex = 65535;
}




} // end of namespace


// ------------------ end of Shared.cs -----------------
#endregion



#region SharedTypes
// -----------------------------------
//  SharedTypes.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{

public static class Constants
{
	public const uint SchemaHash = 0xC0D233E6;
}
		

// -------------------------------------------
// Shared Enum Types
// -------------------------------------------

// --- Shared Enum Types --


// -------------------------------------------
// Shared Struct Types
// -------------------------------------------

// --- Shared Struct Types --

}

// ------------------ end of SharedTypes.cs -----------------
#endregion



#region ComponentData
// -----------------------------------
//  ComponentData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	
	
 
	
	
	// EcsComponentData: InternalLocalUserData
	public struct LocalUser : IComponentData
	{
		public int localIndex;
	}
	
	
	
	// EcsComponentData: InternalWorldPositionQueryData
	public struct WorldPositionQuery : IComponentData
	{
		public float3 position;
	}
	
	
	
	// EcsComponentData: InternalCoherenceSessionComponentData
	public struct CoherenceSessionComponent : IComponentData
	{
	}
	
	

}


// ------------------ end of ComponentData.cs -----------------
#endregion



#region BufferElementData
// -----------------------------------
//  BufferElementData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	


}


// ------------------ end of BufferElementData.cs -----------------
#endregion



#region SerializeCreateEntity
// -----------------------------------
//  SerializeCreateEntity.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Message.Serializer.Serialize;
    using Piot.Log;
    using Unity.Entities;
    using Unity.Transforms;
    using IOutBitStream = Piot.Brook.IOutBitStream;
    using global::Coherence.Generated.FirstProject;

    public class SerializeCreateEntityRequest
    {
        
        public static void SerializeComponentsInMessageFormat(EntityManager entityManager,
            Entity entity, uint[] foundComponentTypes, IOutBitStream bitStream, ILog log)
        {
            var protocolOutStream = new FieldStream.Serialize.Streams.OutBitStream(bitStream, log);

            foreach (var coherenceComponentType in foundComponentTypes)
            {
				ComponentTypeIdSerializer.Serialize(coherenceComponentType, bitStream);

				switch (coherenceComponentType)
                {
					
                    case TypeIds.InternalWorldPositionComponent:
					{
						var data = entityManager.GetComponentData<Translation>(entity);
						MessageSerializers.WorldPositionComponent(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalLocalUser:
					{
						var data = entityManager.GetComponentData<LocalUser>(entity);
						MessageSerializers.LocalUser(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalWorldPositionQuery:
					{
						var data = entityManager.GetComponentData<WorldPositionQuery>(entity);
						MessageSerializers.WorldPositionQuery(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalCoherenceSessionComponent:
					{
						var data = entityManager.GetComponentData<CoherenceSessionComponent>(entity);
						MessageSerializers.CoherenceSessionComponent(protocolOutStream, data);
						break;
					}
					

                    default:
                    {
                        log.Warning($"Unknown component", "component", coherenceComponentType);
                        break;
                    }
                }
            }
        }
    }
}

// ------------------ end of SerializeCreateEntity.cs -----------------
#endregion



#region DeserializeComponentUpdate
// -----------------------------------
//  DeserializeComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.Brook;
    using Piot.Log;
	using Unity.Entities;
	using Unity.Transforms;
    using DeltaEcs;
    using global::Coherence.Generated.FirstProject;
    using Piot.SimulationFrame;
    using Replication.Client.Unity.Ecs;

    public class DeserializeComponentUpdateGenerated
    {

        private static void DeserializeWorldPositionComponent(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {
			// No need to read empty components
			if (((ComponentType)typeof(Translation)).IsZeroSized)
			{
				if (!entityManager.HasComponent<Translation>(entity))
				{
					entityManager.AddComponent<Translation>(entity);
				}
				return;
			}

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Translation();
				UnityReaders.Read(ref temp, protocolStream);
				return;
            }
            

			// Ensure entities with interpolation also have Interpolation components and Sample components
			if (!entityManager.HasComponent<InterpolationComponent_Translation>(entity))
			{
				entityManager.AddComponent<InterpolationComponent_Translation>(entity);
				entityManager.AddComponent<Sample_Translation>(entity);
			}

			// Append buffer for components that use interpolation
			var tempComponentData = new Translation();
			UnityReaders.Read(ref tempComponentData, protocolStream);
			if (justCreated) // Hack
			{
				entityManager.SetComponentData(entity, tempComponentData);
			}
			InterpolationSystem_Translation.AppendBuffer(entity, tempComponentData, entityManager.World, (ulong) simulationFrame.Frame);

		}

        private static void DeserializeLocalUser(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {
			// No need to read empty components
			if (((ComponentType)typeof(LocalUser)).IsZeroSized)
			{
				if (!entityManager.HasComponent<LocalUser>(entity))
				{
					entityManager.AddComponent<LocalUser>(entity);
				}
				return;
			}

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new LocalUser();
				UnityReaders.Read(ref temp, protocolStream);
				return;
            }
            

			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<LocalUser>(entity);
			UnityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);

		}

        private static void DeserializeWorldPositionQuery(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {
			// No need to read empty components
			if (((ComponentType)typeof(WorldPositionQuery)).IsZeroSized)
			{
				if (!entityManager.HasComponent<WorldPositionQuery>(entity))
				{
					entityManager.AddComponent<WorldPositionQuery>(entity);
				}
				return;
			}

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new WorldPositionQuery();
				UnityReaders.Read(ref temp, protocolStream);
				return;
            }
            

			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<WorldPositionQuery>(entity);
			UnityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);

		}

        private static void DeserializeCoherenceSessionComponent(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {
			// No need to read empty components
			if (((ComponentType)typeof(CoherenceSessionComponent)).IsZeroSized)
			{
				if (!entityManager.HasComponent<CoherenceSessionComponent>(entity))
				{
					entityManager.AddComponent<CoherenceSessionComponent>(entity);
				}
				return;
			}

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new CoherenceSessionComponent();
				UnityReaders.Read(ref temp, protocolStream);
				return;
            }
            

			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<CoherenceSessionComponent>(entity);
			UnityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);

		}

        

        public static void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, false, log);
		}

        public static void ReadComponentDataUpdateEx(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, bool justCreated, ILog log)
        {
            var componentOwnership = Deserializator.ReadComponentOwnership(bitStream, log); // Read bit from stream...
            componentOwnership = entityManager.HasComponent<CoherenceSimulateComponent>(entity); // Then overwrite it with entity ownership.
            var inProtocolStream = new Coherence.FieldStream.Deserialize.Streams.InBitStream(bitStream, log);
            switch (componentType)
            {
				
			case TypeIds.InternalWorldPositionComponent:
				DeserializeWorldPositionComponent(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalLocalUser:
				DeserializeLocalUser(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalWorldPositionQuery:
				DeserializeWorldPositionQuery(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalCoherenceSessionComponent:
				DeserializeCoherenceSessionComponent(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				

			default:
				log.Warning("couldn't find component", "componentType", componentType);
				break;
			}
		}
		
        public static void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
#region Commands

#endregion

            switch (componentType)
            {

				case TypeIds.InternalWorldPositionComponent:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Translation>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPositionComponent_Sync>(entity) && entityManager.GetComponentData<WorldPositionComponent_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Translation());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalLocalUser:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<LocalUser_Sync>(entity) && entityManager.GetComponentData<LocalUser_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new LocalUser());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalWorldPositionQuery:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPositionQuery_Sync>(entity) && entityManager.GetComponentData<WorldPositionQuery_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new WorldPositionQuery());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalCoherenceSessionComponent:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity) && entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new CoherenceSessionComponent());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

                default:
				{
                    log.Warning("can not create component type");
                    break;
				}
            }
        }		
    }

    public class ComponentDeserializeWrapper : ISchemaSpecificComponentDeserialize
    {
        public void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            DeserializeComponentUpdateGenerated.CreateIfNeededAndReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }

        public void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            DeserializeComponentUpdateGenerated.ReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }
    }

}

// ------------------ end of DeserializeComponentUpdate.cs -----------------
#endregion



#region DeserializeAndSkipComponentUpdate
// -----------------------------------
//  DeserializeAndSkipComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.Log;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;
    using Replication.Client.Unity.Ecs;

    public class DeserializeComponentUpdateSkipGenerated
    {
		
		private static void DeserializeWorldPositionComponent(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Translation();
            UnityReaders.Read(ref ignored, protocolStream);
		}
		
		private static void DeserializeLocalUser(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new LocalUser();
            UnityReaders.Read(ref ignored, protocolStream);
		}
		
		private static void DeserializeWorldPositionQuery(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new WorldPositionQuery();
            UnityReaders.Read(ref ignored, protocolStream);
		}
		
		private static void DeserializeCoherenceSessionComponent(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new CoherenceSessionComponent();
            UnityReaders.Read(ref ignored, protocolStream);
		}
		
 
		public static void SkipComponentDataUpdate(uint componentType, Coherence.Replication.Protocol.Definition.IInBitStream inProtocolStream, ILog log)
        {
			switch (componentType)
            {

                case TypeIds.InternalWorldPositionComponent:
					DeserializeWorldPositionComponent(inProtocolStream);
                    break;

                case TypeIds.InternalLocalUser:
					DeserializeLocalUser(inProtocolStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
					DeserializeWorldPositionQuery(inProtocolStream);
                    break;

                case TypeIds.InternalCoherenceSessionComponent:
					DeserializeCoherenceSessionComponent(inProtocolStream);
                    break;

			}
		}
    }
    
    public class DeserializeComponentsAndSkipWrapper : ISchemaSpecificComponentDeserializerAndSkip
    {
        public void DeserializeAndSkipComponent(uint componentTypeId, Coherence.Replication.Protocol.Definition.IInBitStream protocolOutStream, ILog log)
        {
            DeserializeComponentUpdateSkipGenerated.SkipComponentDataUpdate(componentTypeId, protocolOutStream, log);
        }
    }    
}

// ------------------ end of DeserializeAndSkipComponentUpdate.cs -----------------
#endregion



#region SyncSendSystem
// -----------------------------------
//  SyncSendSystem.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using System.Collections.Generic;
    using System.Linq;
    using Coherence.Replication.Unity;
    using Replication.Client.Unity.Ecs;
    using UnityEngine;
    using Unity.Collections;
    using Unity.Entities;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;
    using Piot.Brook;
    using Piot.Log;

    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [AlwaysUpdateSystem]
    public class SyncSendSystem : SystemBase
    {
        private Sender sender;
        private bool isBooted;
        private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;
		public Sender Sender => sender;

		private const int hackMaxKeysCount = 20;	// Max component changes to send per frame

        void BootUp()
        {
            Debug.Log($"created messageChannels");
            var netSys = World.GetOrCreateSystem<NetworkConnectSystem>();
            var wrapper = new SerializeComponentUpdatesWrapper();
            sender = new Sender(World, netSys.Connector, netSys.Mapper, wrapper, netSys.SentPacketsCache, netSys.Log);
            destroyedEntities = netSys.DestroyedEntities;
        }

        protected override void OnUpdate()
        {
	        if (!isBooted)
	        {
		        BootUp();
		        isBooted = true;
	        }

            var simulationFrame = World.GetOrCreateSystem<CoherenceSimulationSystemGroup>().SimulationFrame;

#region detect deleted entities
            // Ensure all simulated entities have their system state component in order to track entity destruction
            Entities.WithNone<CoherenceSimulateComponentLinger>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponent simulate) =>
            {
	            EntityManager.AddComponentData(entity, new CoherenceSimulateComponentLinger());
            }).WithStructuralChanges().WithoutBurst().Run();

	        // Keep track of locally destroyed entities so that SyncReceiveSystem does not revive them
	        var commandBuffer = World.GetExistingSystem<EndSimulationEntityCommandBufferSystem>().CreateCommandBuffer();
            Entities.WithNone<CoherenceSimulateComponent>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponentLinger sync) =>
            {
                destroyedEntities.TryAdd(entity, new DetectedEntityDeletion { Entity = entity, simulationFrame = simulationFrame, serialized = false});
                commandBuffer.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
            }).WithoutBurst().Run();

            // Clear entities that were locally destroyed over 10s ago, to prevent hashmap from overflowing  
            var kv = destroyedEntities.GetKeyValueArrays(Allocator.TempJob);
            for (var i=0; i<kv.Values.Length; i++)
            {
                if (simulationFrame > kv.Values[i].simulationFrame + 60*10)
                {
                    destroyedEntities.Remove(kv.Keys[i]);
                }
            }
            kv.Dispose();
#endregion

            var canWeSend = sender.OnUpdate();


			var componentChanges = new NativeMultiHashMap<uint, ComponentChange>(2048, Allocator.TempJob);
			var localComponentChanges = componentChanges.AsParallelWriter();

#region Detect Removed Component Data
			
			
			Entities.WithNone<Translation>().ForEach((Entity entity, ref WorldPositionComponent_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPositionComponent,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();
			
			
			
			Entities.WithNone<LocalUser>().ForEach((Entity entity, ref LocalUser_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalLocalUser,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();
			
			
			
			Entities.WithNone<WorldPositionQuery>().ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPositionQuery,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();
			
			
			
			Entities.WithNone<CoherenceSessionComponent>().ForEach((Entity entity, ref CoherenceSessionComponent_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalCoherenceSessionComponent,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();
			
			 
			Dependency.Complete();
#endregion
	
			if (!canWeSend)
			{
				componentChanges.Dispose();
				return;
			}



#region Detect Added Component Data
			
			
			Entities.WithAll<Translation, CoherenceSimulateComponent>().WithNone<WorldPositionComponent_Sync>().ForEach((Entity entity) =>
			{
				
			
				EntityManager.AddComponentData(entity, new WorldPositionComponent_Sync 
				{
					howImportantAreYou = 1000
				});
			}).WithStructuralChanges().Run();

			
			
			Entities.WithAll<LocalUser, CoherenceSimulateComponent>().WithNone<LocalUser_Sync>().ForEach((Entity entity) =>
			{
				
			
				EntityManager.AddComponentData(entity, new LocalUser_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

			
			
			Entities.WithAll<WorldPositionQuery, CoherenceSimulateComponent>().WithNone<WorldPositionQuery_Sync>().ForEach((Entity entity) =>
			{
				
			
				EntityManager.AddComponentData(entity, new WorldPositionQuery_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

			
			
			Entities.WithAll<CoherenceSessionComponent, CoherenceSimulateComponent>().WithNone<CoherenceSessionComponent_Sync>().ForEach((Entity entity) =>
			{
				
			
				EntityManager.AddComponentData(entity, new CoherenceSessionComponent_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

			 
#endregion


#region Detect Component Data changes

			
		
			Entities.ForEach((Entity entity, ref WorldPositionComponent_Sync sync, in Translation data, in CoherenceSimulateComponent simulate) =>
			{
				sync.accumulatedPriority += sync.howImportantAreYou;

				uint mask = 0;

				if (!sync.hasBeenSerialized) mask = 1;


                if (!data.Value.Equals(sync.lastSentData.Value) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPositionComponent,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();
		
			
		
			Entities.ForEach((Entity entity, ref LocalUser_Sync sync, in LocalUser data, in CoherenceSimulateComponent simulate) =>
			{
				sync.accumulatedPriority += sync.howImportantAreYou;

				uint mask = 0;

				if (!sync.hasBeenSerialized) mask = 1;


                if (data.localIndex != sync.lastSentData.localIndex) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalLocalUser,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();
		
			
		
			Entities.ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in WorldPositionQuery data, in CoherenceSimulateComponent simulate) =>
			{
				sync.accumulatedPriority += sync.howImportantAreYou;

				uint mask = 0;

				if (!sync.hasBeenSerialized) mask = 1;


                if (!data.position.Equals(sync.lastSentData.position) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPositionQuery,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();
		
			
		
			Entities.ForEach((Entity entity, ref CoherenceSessionComponent_Sync sync, in CoherenceSessionComponent data, in CoherenceSimulateComponent simulate) =>
			{
				sync.accumulatedPriority += sync.howImportantAreYou;

				uint mask = 0;

				if (!sync.hasBeenSerialized) mask = 1;


				if (mask != 0 || sync.resendMask != 0)
				{
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalCoherenceSessionComponent,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();
		
			

#endregion


        	Dependency.Complete();

			var changesToSend = GetPrioritizedChanges(componentChanges, hackMaxKeysCount);
	
			var partsWorld = CreatePartsWorld.ComponentChangesToPartsWorld(destroyedEntities, changesToSend.ToArray(), sender.Mapper);

			if (!partsWorld.IsEmpty)
			{
			}
	
			componentChanges.Clear();
			sender.Send(partsWorld);

			componentChanges.Dispose();
        }

        private static List<ComponentChange> GetPrioritizedChanges(NativeMultiHashMap<uint, ComponentChange> componentChanges, int maxChanges)
        {
	        var componentChangesList = new List<ComponentChange>();
		
	        // The keys array may contain duplicate elements beyond index nUniqueKeys  
	        (var keys, var nUniqueKeys) = componentChanges.GetUniqueKeyArray(Allocator.Temp);
	        
	        // Reverse key array to sort by decreasing priority
	        var orderedKeys = keys.ToList().Take(nUniqueKeys).OrderBy(priority => priority).Reverse();
	        
	        // Select changes with highest priority,  
	        foreach (var priority in orderedKeys)
	        {
		        var changes = componentChanges.GetValuesForKey(priority);
		        foreach (var change in changes)
		        {
			        componentChangesList.Add(change);
			        if (componentChangesList.Count > maxChanges)
			        {
				        return componentChangesList;
			        }
		        }
	        }

	        return componentChangesList;
        }
    }

    public class CreateEntityRequestSerializeWrapper : ISchemaSpecificSerializeComponentsInMessageFormat
    {
        public void SerializeComponentsInMessageFormat(EntityManager entityManager, Entity entity, uint[] foundComponentTypes,
            IOutBitStream bitStream, ILog log)
        {
            SerializeCreateEntityRequest.SerializeComponentsInMessageFormat(entityManager, entity, foundComponentTypes, bitStream, log);
        }
    }

}
// ------------------ end of SyncSendSystem.cs -----------------
#endregion



#region SyncReceiveSystem
// -----------------------------------
//  SyncReceiveSystem.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.SimulationFrame;
    using Protocol.Deserialize;
    using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Sdk.Unity;

    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(InitializationSystemGroup))]
    [AlwaysUpdateSystem]
    public class SyncReceiveSystem : SystemBase
    {
        private Receiver receiver;
        CoherenceSimulationSystemGroup simGroup;
        private bool hasInitialTime;
        private bool isBooted;

        private void BootUp()
        {
	        simGroup = World.GetExistingSystem<CoherenceSimulationSystemGroup>();
            var skipper = new DeserializeComponentsAndSkipWrapper();
            var deserializeComponents = new ComponentDeserializeWrapper();
            var netSys = World.GetOrCreateSystem<NetworkConnectSystem>();
            var commandPerform = new PerformCommands();
            var receiveUpdate = new ReceiveUpdate(deserializeComponents, skipper, netSys.Mapper, netSys.DestroyedEntities, netSys.Log);
            receiver = new Receiver(World, netSys.Mapper, netSys.Connector, receiveUpdate, commandPerform, netSys.SentPacketsCache, netSys.Log);
        }

        private void ChangeClockSpeed(ClockSpeedFactor factor)
        {
            const float desiredTimestep = 1f / 60f;
            var timeStep = 0f;
            if (factor.FactorTimesThousand <= 1)
            {
            }
            else
            {
	            timeStep = desiredTimestep * 1000f / factor.FactorTimesThousand;
            }

            simGroup.SetTimeStep(true, timeStep, 0);
        }

        protected override void OnUpdate()
        {
	        if (!isBooted)
	        {
		        isBooted = true;
		        BootUp();
	        }

            var simulationFrame = new AbsoluteSimulationFrame { Frame = (long)simGroup.SimulationFrame };
            var adjust = receiver.OnUpdate(simulationFrame);

            if (adjust.State != SpecialCommandState.Ignore)
	        {
	            var needsToOverwriteTime = (!hasInitialTime && adjust.SimulationFrame.Frame != 0) || adjust.State == SpecialCommandState.Reset;

	            if (needsToOverwriteTime)
	            {
	                simGroup.SetSimulationFrame((ulong)adjust.SimulationFrame.Frame);
	                hasInitialTime = true;
	            }

	            ChangeClockSpeed(adjust.ClockSpeed);
            }
        }
    }
}

// ------------------ end of SyncReceiveSystem.cs -----------------
#endregion



#region SyncComponent
// -----------------------------------
//  SyncComponent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Unity.Entities;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;


    public struct WorldPositionComponent_Sync : IComponentData
    {
        public Translation lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct LocalUser_Sync : IComponentData
    {
        public LocalUser lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct WorldPositionQuery_Sync : IComponentData
    {
        public WorldPositionQuery lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct CoherenceSessionComponent_Sync : IComponentData
    {
        public CoherenceSessionComponent lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


}


// ------------------ end of SyncComponent.cs -----------------
#endregion



#region SerializeComponentUpdate
// -----------------------------------
//  SerializeComponentUpdate.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using System;
	using Unity.Entities;
	using Unity.Transforms;
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Protocol.Definition;
	using Replication.Client.Unity.Ecs;

    public static class SerializeComponentUpdatesGenerated
    {

        private static void SerializeWorldPositionComponent(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Translation>(entity);
            UnityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPositionComponent_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private static void SerializeLocalUser(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<LocalUser>(entity);
            UnityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<LocalUser_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private static void SerializeWorldPositionQuery(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<WorldPositionQuery>(entity);
            UnityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private static void SerializeCoherenceSessionComponent(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

    
        public static void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint componentType, uint fieldMask, IOutBitStream protocolOutStream)
        {
            switch (componentType)
            {

                case TypeIds.InternalWorldPositionComponent:
                    SerializeWorldPositionComponent(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalLocalUser:
                    SerializeLocalUser(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
                    SerializeWorldPositionQuery(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalCoherenceSessionComponent:
                    SerializeCoherenceSessionComponent(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                default:
                    throw new Exception($"unknown componentType {componentType}");
            }
        }
    
        
        public static void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
        {
            switch (componentTypeId)
            {

                case TypeIds.InternalWorldPositionComponent:
                {
                    var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var syncData = entityManager.GetComponentData<LocalUser_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalCoherenceSessionComponent:
                {
                    var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }


                default:
                    throw new Exception($"unknown componentType {componentTypeId}");
            }
        }
    }
    
    class SerializeComponentUpdatesWrapper : ISchemaSpecificComponentSerializer
    {
    	public void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint ComponentTypeId, uint fieldMask, IOutBitStream protocolOutStream)
    	{
    		SerializeComponentUpdatesGenerated.SerializeComponent(entityManager, unityEntity, ComponentTypeId, fieldMask, protocolOutStream);
    	}
    	
    	public void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
    	{
            SerializeComponentUpdatesGenerated.UpdateDestructState(entityManager, unityEntity, componentTypeId);
        }
    }

}


// ------------------ end of SerializeComponentUpdate.cs -----------------
#endregion



#region ComponentMaskDeserializers
// -----------------------------------
//  ComponentMaskDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Unity.Transforms;
	using Coherence.Replication.Unity;
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;


public static class UnityReaders
{

	public static uint Read(ref Translation data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
				 data = CoherenceToUnityConverters.ToUnityTranslation(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
   
		return propertyMask;
	}

	
	
	
	
	
	public static uint Read(ref LocalUser data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadIntegerRange(15, -9999);
			       data.localIndex = coherenceField;
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	
	
	public static uint Read(ref WorldPositionQuery data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
			     data.position = CoherenceToUnityConverters.ToUnityfloat3(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	
	
	public static uint Read(ref CoherenceSessionComponent data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

       
		return propertyMask;
	}

	
	
}

}

// ------------------ end of ComponentMaskDeserializers.cs -----------------
#endregion



#region ComponentMaskSerializers
// -----------------------------------
//  ComponentMaskSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Replication.Unity;
	using Unity.Transforms;


	public static class UnityWriters
	{
		public static void Write(in Translation data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{

			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = CoherenceToUnityConverters.FromUnityTranslation(data);
					bitstream.WriteVector3f(v, 24, 2400);
				
			}
			propertyMask >>= 1;

	 }

		
		
		
		
		
		
			public static void Write(in LocalUser data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
					
				}
				propertyMask >>= 1;
	
	     }

		
		
		
		
			public static void Write(in WorldPositionQuery data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						var v = CoherenceToUnityConverters.FromUnityfloat3(data.position);
						bitstream.WriteVector3f(v, 24, 2400);
					
				}
				propertyMask >>= 1;
	
	     }

		
		
		
		
			public static void Write(in CoherenceSessionComponent data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	     }

		
		
	}
}

// ------------------ end of ComponentMaskSerializers.cs -----------------
#endregion



#region MessageSerializers
// -----------------------------------
//  MessageSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;
	using Replication.Unity;


public static class MessageSerializers
{
	public static void WorldPositionComponent(IOutBitStream bitstream, Translation data)
	{
		var internalData = CoherenceToUnityConverters.FromUnityTranslation(data);
		bitstream.WriteVector3f(internalData, 24, 2400);
	}






	public static void LocalUser(IOutBitStream bitstream, LocalUser data)
	{

			
				bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
			

	}



	public static void WorldPositionQuery(IOutBitStream bitstream, WorldPositionQuery data)
	{

			
				var converted_position = CoherenceToUnityConverters.FromUnityfloat3(data.position);
				bitstream.WriteVector3f(converted_position, 24, 2400);
			

	}



	public static void CoherenceSessionComponent(IOutBitStream bitstream, CoherenceSessionComponent data)
	{

	}



/// ------------------------ Requests --------------------------



}

}

// ------------------ end of MessageSerializers.cs -----------------
#endregion



#region MessageDeserializers
// -----------------------------------
//  MessageDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;	
	using Replication.Unity;


public static class MessageDeserializers
{
	public static void WorldPositionComponent(IInBitStream bitstream, ref Translation data)
	{
		var coherenceVector = bitstream.ReadVector3f(24, 2400);
		data = CoherenceToUnityConverters.ToUnityTranslation(coherenceVector);
	}







	public static void LocalUser(IInBitStream bitstream, ref LocalUser data)
	{

			
				data.localIndex =  bitstream.ReadIntegerRange(15, -9999);
			
     
	}



	public static void WorldPositionQuery(IInBitStream bitstream, ref WorldPositionQuery data)
	{

			
				var position = bitstream.ReadVector3f(24, 2400);
				data.position = CoherenceToUnityConverters.ToUnityfloat3(position);
			
     
	}



	public static void CoherenceSessionComponent(IInBitStream bitstream, ref CoherenceSessionComponent data)
	{
     
	}



}

}

// ------------------ end of MessageDeserializers.cs -----------------
#endregion



#region CommandDeserializers
// -----------------------------------
//  CommandDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
    using Piot.Log;
    using Unity.Entities;
	using Replication.Client.Unity.Ecs;

    
    public class PerformCommands : IPerformCommand
    {
        public void PerformCommand(EntityManager mgr, Entity entity, uint commandTypeID, Coherence.Replication.Protocol.Definition.IInBitStream bitStream, ILog log)
        {
            switch (commandTypeID)
            {

            }
        }
    }
}


// ------------------ end of CommandDeserializers.cs -----------------
#endregion



#region RuntimeSystem
// -----------------------------------
//  RuntimeSystem.cs
// -----------------------------------
			
namespace Coherence.Sdk.Unity
{
    using Coherence.Generated.Internal.FirstProject;
    using global::Unity.Entities;
    using global::Unity.Transforms;
    using Piot.Log;
    using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Client.Connection;
    using global::Coherence.Generated.FirstProject;

    [UpdateInGroup(typeof(SimulationSystemGroup))]
    public class CoherenceRuntimeSystem : ComponentSystem
    {
        private bool offline;
        private NetworkConnectSystem connectSystem;
        private ILog log;

        public void Connect(string hostname, ConnectionType connectionType)
        {
            offline = hostname == "offline"; // HACK

            log = World.GetOrCreateSystem<NetworkConnectSystem>().Log;

            var commandBuffer = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>().CreateCommandBuffer()
                .AsParallelWriter();

            World.GetOrCreateSystem<OfflineEntityDetectorSystem>().Enabled = offline;
            World.GetOrCreateSystem<SyncSendSystem>().Enabled = !offline;
            World.GetOrCreateSystem<SyncReceiveSystem>().Enabled = !offline;
            World.GetOrCreateSystem<NetworkConnectSystem>().Enabled = !offline;

            if (!offline)
            {
                connectSystem = World.GetOrCreateSystem<NetworkConnectSystem>();
                ConnectionHelper.Connect(connectSystem.Connector, hostname, connectionType);
            }
        }

        protected override void OnCreate()
        {
            #region Register all known component types and their enums
                       GlobalLookups.Register<Translation>(TypeEnums.InternalWorldPositionComponent);
           GlobalLookups.Register<LocalUser>(TypeEnums.InternalLocalUser);
           GlobalLookups.Register<WorldPositionQuery>(TypeEnums.InternalWorldPositionQuery);
           GlobalLookups.Register<CoherenceSessionComponent>(TypeEnums.InternalCoherenceSessionComponent);

            #endregion

            #region Register all known component types and their component type id
                       GlobalTypeIdLookups.Register<Translation>(TypeIds.InternalWorldPositionComponent);
           GlobalTypeIdLookups.Register<LocalUser>(TypeIds.InternalLocalUser);
           GlobalTypeIdLookups.Register<WorldPositionQuery>(TypeIds.InternalWorldPositionQuery);
           GlobalTypeIdLookups.Register<CoherenceSessionComponent>(TypeIds.InternalCoherenceSessionComponent);

            #endregion

            base.OnCreate();
        }

        protected override void OnUpdate()
        {
        }

        public bool IsConnected => offline || connectSystem.IsConnected;
    }
}

// ------------------ end of RuntimeSystem.cs -----------------
#endregion



#region OfflineSystem
// -----------------------------------
//  OfflineSystem.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using global::Coherence.Generated.FirstProject;
    using global::Unity.Entities;
    using global::Unity.Transforms;
    using Replication.Unity;
	using Replication.Client.Unity.Ecs;
	
    [AlwaysUpdateSystem]
    public class OfflineEntityDetectorSystem : SystemBase
    {
        private bool hasSpawnedLocalUser;

        protected override void OnUpdate()
        {
            if (!hasSpawnedLocalUser)
            {
                var mgr = World.EntityManager;

                var localUserEntity = mgr.CreateEntity();
                mgr.AddComponentData(localUserEntity, new LocalUser { localIndex = 0 });
                hasSpawnedLocalUser = true;
            }

            Dependency.Complete();
        }
    }
}

// ------------------ end of OfflineSystem.cs -----------------
#endregion



#region DetectEntityCreateAndDestroy
// -----------------------------------
//  DetectEntityCreateAndDestroy.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Replication.Client.Unity.Ecs;
	using Unity.Collections;
    using Unity.Entities;
    using Replication.Unity;
    using Unity.Transforms;
    using UnityEngine;    
    
    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(SyncSendSystem))]
    public class DetectEntityCreateSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            if (World.GetExistingSystem<SyncSendSystem>().Sender == null)
            {
                Debug.LogWarning("No sender");
                return;
            }
            var mapper = World.GetExistingSystem<SyncSendSystem>().Sender.Mapper;
            
            Entities.WithNone<CoherenceMappedComponent>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponent simulate) =>
            {
                var id = mapper.NextEntityId;
                mapper.Add(id, entity);
                EntityManager.AddComponent<CoherenceMappedComponent>(entity);
            }).WithStructuralChanges().WithoutBurst().Run();

            Dependency.Complete();
       }
    }
} // namespace
        


// ------------------ end of DetectEntityCreateAndDestroy.cs -----------------
#endregion



#region DetectCommandSent
// -----------------------------------
//  DetectCommandSent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using UnityEngine;
    using Unity.Entities;
    using global::Coherence.Generated.FirstProject;

    using Message;
    using Message.Serializer.Serialize;
    using Piot.Brisk.Connect;
    using Piot.Brook;
    using Piot.Log;
    using Replication.Client.Unity.Ecs;
    using Replication.Unity;

   // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [AlwaysUpdateSystem]
    public class DetectCommandsSentSystem : SystemBase
    {
	    private Sender cachedSender;

	    protected override void OnUpdate()
	    {
		    if (cachedSender == null)
		    {
			    cachedSender = World.GetExistingSystem<SyncSendSystem>().Sender;
			    if (cachedSender == null)
			    {
				    return;
			    }
            }

	        var log = new Log(new UnityLogger(LogLevel.Debug));

	        var burstSender = cachedSender;
	        var mapper = cachedSender.Mapper;



        }
    }

}


// ------------------ end of DetectCommandSent.cs -----------------
#endregion



#region RecieveUpdate
// -----------------------------------
//  RecieveUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Coherence.Ecs;
    using Coherence.DeltaEcs;
    using Coherence.Replication.Unity;
    using Coherence.Replication.Client.Unity.Ecs;
    using global::Unity.Transforms;
    using global::Unity.Collections;
    using global::Unity.Entities;
    using Piot.Brook;
    using Piot.Log;
    using Piot.SimulationFrame;
    using global::Coherence.Generated.FirstProject;

    public class ReceiveUpdate : IReceiveUpdate
    {
        private readonly ISchemaSpecificComponentDeserialize componentDeserialize;
        private readonly ILog log;
        private UnityMapper mapper;
        private readonly ISchemaSpecificComponentDeserializerAndSkip componentSkip;
        private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;

        public ReceiveUpdate(ISchemaSpecificComponentDeserialize componentDeserialize,  ISchemaSpecificComponentDeserializerAndSkip componentSkip, UnityMapper mapper, NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities, ILog log)
        {
            this.componentDeserialize = componentDeserialize;
            this.componentSkip = componentSkip;
            this.mapper = mapper;
            this.log = log;
            this.destroyedEntities = destroyedEntities;
        }

        private void DestroyComponentData(EntityManager entityManager, Entity entity, uint componentType)
        {
            switch (componentType)
            {

                case TypeIds.InternalWorldPositionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<Translation>(entity);
                    if (hasComponentData)
                    {
                        entityManager.RemoveComponent<Translation>(entity);
                    }
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
                    if (hasComponentData)
                    {
                        entityManager.RemoveComponent<LocalUser>(entity);
                    }
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
                    if (hasComponentData)
                    {
                        entityManager.RemoveComponent<WorldPositionQuery>(entity);
                    }
                    break;
                }

                case TypeIds.InternalCoherenceSessionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent>(entity);
                    if (hasComponentData)
                    {
                        entityManager.RemoveComponent<CoherenceSessionComponent>(entity);
                    }
                    break;
                }

                default:
                {
                    log.Warning($"Unknown component", "component", componentType);
                    break;
                }
            }
        }

        private void UpdateComponents(EntityManager entityManager, Entity entity, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
        {
            var componentCount = Deserializator.ReadComponentCount(bitStream, log);
            for (var i = 0; i < componentCount; i++)
            {
                var componentState = Deserializator.ReadComponentState(bitStream, log);
                var componentId = Deserializator.ReadComponentId(bitStream, log);
                switch (componentState)
                {
                    case ComponentState.Construct:
                        {
                            var componentTypeId = Deserializator.ReadComponentTypeId(bitStream, log);

                            componentDeserialize.CreateIfNeededAndReadComponentDataUpdate(entityManager,
                                entity, componentTypeId, simulationFrame, bitStream, log);
                        }
                        break;
                    case ComponentState.Update:
                        {
                            // TODO: lookup component ID from state.
                            var updateComponentTypeId = componentId;
                            componentDeserialize.ReadComponentDataUpdate(entityManager, entity,
                                updateComponentTypeId, simulationFrame, bitStream, log);
                        }
                        break;
                    case ComponentState.Destruct:
                        {
                            var destroyComponentTypeId = componentId;
                            DestroyComponentData(entityManager, entity, destroyComponentTypeId);
                        }
                        break;
                }
            }
        }

        public void PerformUpdate(EntityManager entityManager, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
        {
            var deserializeEntity = new Deserializator(log);
            
            while (deserializeEntity.ReadEntity(bitStream, out var entityWithMeta, log))
            {
                var entity = mapper.ToUnityEntity(entityWithMeta.EntityId, false);
                
                // Skip locally destroyed entities
                if (destroyedEntities.ContainsKey(entity))
                {
                    if (!entityWithMeta.IsDeleted)
                    {
                        DeserializeComponentSkip.SkipComponents(componentSkip, bitStream, log);
                    }
                    continue;
                }
                
                // Meta information concerns entity creation, destruction and ownership
	            if (entityWithMeta.HasMeta)
		        {
					entity = PerformEntityMetaUpdate(entityManager, entityWithMeta, entity);
	            }
	            
                // Deserialize and apply component updates
                if (entity != default)
                {
                    UpdateComponents(entityManager, entity, simulationFrame, bitStream);
                } else if (!entityWithMeta.IsDeleted) 
                {
                    // An error has occurred if the entity is null unless it's because it was just deleted
                    log.Warning($"Entity is missing {entityWithMeta.EntityId}");
                }
            }
        }

        private Entity PerformEntityMetaUpdate(EntityManager entityManager, Deserializator.EntityWithMeta entityWithMeta, Entity entity)
	    {
            // Entities are DELETED explicitly by the IsDeleted flag
            if (entityWithMeta.IsDeleted)
            {
                if (entity != default)
                {
                    if (entityManager.Exists(entity))
                    {
                        mapper.Remove(entityWithMeta.EntityId);	// This internally requires entity to exist...
						entityManager.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
                        entityManager.DestroyEntity(entity);	// ...so this must be executed afterwards ...
                    } else 
                    {
                        log.Warning($"Entity has already been deleted: {entityWithMeta.EntityId} : {entity}");
                    }
                } else 
                {
                    log.Warning($"Attempted to delete missing entity: {entityWithMeta.EntityId}");
                }

                return default;
            }
            
		    // Entities are CREATED implicitly if they do not exist
		    if (entity == default || !entityManager.Exists(entity))
		    {
			    if (entity != default)
			    {
				    UnityEngine.Debug.LogWarning("entity might still be mapped: " + entity + " CID: " + entityWithMeta.EntityId);
			    }
			    entity = entityManager.CreateEntity();
			    mapper.Add(entityWithMeta.EntityId, entity);
			    entityManager.AddComponent<CoherenceMappedComponent>(entity);
		    }
		    
		    // Entities OWNERSHIP determines iff they should have CoherenceSimulateComponent
		    var hasComponentData = entityManager.HasComponent<CoherenceSimulateComponent>(entity);
		    if (hasComponentData && !entityWithMeta.Ownership)
		    {
			    entityManager.RemoveComponent<CoherenceSimulateComponent>(entity);
				entityManager.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
				RemoveSyncComponents(entityManager, entity);
		    }
		    else if (!hasComponentData && entityWithMeta.Ownership)
		    {
			    entityManager.AddComponentData(entity, new CoherenceSimulateComponent());
			    RemoveInterpolationComponents(entityManager, entity);
		    }

            return entity;
        }
        
        public void UpdateResendMask(EntityManager entityManager, Coherence.Ecs.EntityId entityId, uint componentTypeId, uint fieldMask)
        {
            var entity = mapper.ToUnityEntity(entityId);
            
            switch (componentTypeId)
            {

                case TypeIds.InternalWorldPositionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<WorldPositionComponent_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(entity);

                        syncData.resendMask |= fieldMask;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
                        log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
                    }
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);

                        syncData.resendMask |= fieldMask;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
                        log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
                    }
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

                        syncData.resendMask |= fieldMask;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
                        log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
                    }
                    break;
                }

                case TypeIds.InternalCoherenceSessionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);

                        syncData.resendMask |= fieldMask;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
                        log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
                    }
                    break;
                }

                default:
                {
                    log.Warning($"Unknown component", "component", componentTypeId);
                    break;
                }
            }
        }
        
		public void UpdateHasReceivedConstructor(EntityManager entityManager, Coherence.Ecs.EntityId entityId, uint componentTypeId)
		{
			var entity = mapper.ToUnityEntity(entityId, false);
            
			// The entity has been deleted since the packet was sent
			if (destroyedEntities.ContainsKey(entity))
			{
				return;
			}

            if (!entityManager.Exists(entity))
            {
                log.Warning($"Entity does not exist: {entity} ComponentTypeId: {componentTypeId}");
                return;
            }
            
            if (!entityManager.HasComponent<CoherenceSimulateComponent>(entity))
            {
				// Ownership may have been lost since the packet was sent
                log.Trace($"Entity is missing CoherenceSimulateComponent: {entity} ComponentTypeId: {componentTypeId}");
                return;
            }

            var sim = entityManager.GetComponentData<CoherenceSimulateComponent>(entity);
            sim.hasReceivedConstructor = true;
            
            switch (componentTypeId)
            {

                case TypeIds.InternalWorldPositionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<WorldPositionComponent_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(entity);
                        syncData.hasReceivedConstructor = true;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
						// Ownership may have been lost since the packet was sent
                        log.Trace($"Sync component has been destroyed: {entity} WorldPositionComponent_Sync");
                    }
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);
                        syncData.hasReceivedConstructor = true;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
						// Ownership may have been lost since the packet was sent
                        log.Trace($"Sync component has been destroyed: {entity} LocalUser_Sync");
                    }
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);
                        syncData.hasReceivedConstructor = true;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
						// Ownership may have been lost since the packet was sent
                        log.Trace($"Sync component has been destroyed: {entity} WorldPositionQuery_Sync");
                    }
                    break;
                }

                case TypeIds.InternalCoherenceSessionComponent:
                {
                    var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity);
                    if (hasComponentData)
                    {
                        var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);
                        syncData.hasReceivedConstructor = true;
                        entityManager.SetComponentData(entity, syncData);
                    } else 
                    {
						// Ownership may have been lost since the packet was sent
                        log.Trace($"Sync component has been destroyed: {entity} CoherenceSessionComponent_Sync");
                    }
                    break;
                }

                default:
                {
                    log.Warning($"Unknown component", "component", componentTypeId);
                    break;
                }
            }
        }
        
        public void UpdateResendDestroyed(EntityManager entityManager, EntityId entityId, AbsoluteSimulationFrame simulationFrame)
        {
            var entity = mapper.ToUnityEntity(entityId, false);
            if (entity == default)
            {
                log.Warning($"Destroyed entity {entityId} missing from mapper");
                return;
            }
            
            // Flag this entity destruction to be resent
            destroyedEntities[entity] = new DetectedEntityDeletion { Entity = entity, simulationFrame = (ulong)simulationFrame.Frame, serialized = false };
        }
        
        private void RemoveSyncComponents(EntityManager entityManager, Entity entity)
        {

            if (entityManager.HasComponent<WorldPositionComponent_Sync>(entity)) 
            {
                entityManager.RemoveComponent<WorldPositionComponent_Sync>(entity);
            }

            if (entityManager.HasComponent<LocalUser_Sync>(entity)) 
            {
                entityManager.RemoveComponent<LocalUser_Sync>(entity);
            }

            if (entityManager.HasComponent<WorldPositionQuery_Sync>(entity)) 
            {
                entityManager.RemoveComponent<WorldPositionQuery_Sync>(entity);
            }

            if (entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity)) 
            {
                entityManager.RemoveComponent<CoherenceSessionComponent_Sync>(entity);
            }

        }
        
        private void RemoveInterpolationComponents(EntityManager entityManager, Entity entity)
        {


            if (entityManager.HasComponent<InterpolationComponent_Translation>(entity)) 
            {
                entityManager.RemoveComponent<InterpolationComponent_Translation>(entity);
            }
            if (entityManager.HasComponent<Sample_Translation>(entity)) 
            {
                entityManager.RemoveComponent<Sample_Translation>(entity);
            }








        }
    }
}
// ------------------ end of RecieveUpdate.cs -----------------
#endregion



#region DynamicBufferData
// -----------------------------------
//  DynamicBufferData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	

}


// ------------------ end of DynamicBufferData.cs -----------------
#endregion
