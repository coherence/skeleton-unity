// <auto-generated>
// Generated file. DO NOT EDIT!
// Generated from schema 'FirstProject' [0xB1CC45FB]
// File created by coherence-code-generator v0.0.4-a24
// </auto-generated>



#region Shared
// -----------------------------------
//  Shared.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using System;
    using System.Collections.Generic;
	using Replication.Client.Unity.Ecs;


	

static class TypeIds
{

	public const uint InternalWorldPositionComponent = 0;

	public const uint InternalWorldOrientationComponent = 1;

	public const uint InternalLocalUser = 2;

	public const uint InternalWorldPositionQuery = 3;

	public const uint InternalCoherenceSessionComponent = 4;

	public const uint InternalPlayer = 5;

	public const uint InternalShot = 6;

}


enum TypeEnums
{

	InternalWorldPositionComponent = 0,

	InternalWorldOrientationComponent = 1,

	InternalLocalUser = 2,

	InternalWorldPositionQuery = 3,

	InternalCoherenceSessionComponent = 4,

	InternalPlayer = 5,

	InternalShot = 6,

}


internal static class InternalGlobalLookups
{
	internal readonly static Dictionary<Type, TypeEnums> GlobalTypeToEnumLookup = new Dictionary<Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		GlobalTypeToEnumLookup.Add(typeof(T), e);
	}
}

internal static class GlobalLookups
{
	internal readonly static Dictionary<System.Type, TypeEnums> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

internal static class GlobalTypeIdLookups
{
	internal readonly static Dictionary<System.Type, uint> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, uint>();

	internal static uint Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static (uint, bool) LookupUsingType(System.Type t)
	{
		var foundIt = GlobalTypeToEnumLookup.TryGetValue(t, out var value);
		return !foundIt ? ((uint, bool)) (0, foundIt) : (value, true);
	}

	internal static void Register<T>(uint e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

class GlobalTypeIdLookupsWrapper : ITypeIdLookups
{
	public (uint, bool) LookupUsingType(Type t)
	{
		return GlobalTypeIdLookups.LookupUsingType(t);
	}
}

static class RleConstants
{
	public const uint EndOfComponentArray = 255;
	public const uint EndOfComponentIndex = 65535;
}




} // end of namespace


// ------------------ end of Shared.cs -----------------
#endregion



#region SharedTypes
// -----------------------------------
//  SharedTypes.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{

public static class Constants
{
	public const uint SchemaHash = 0xB1CC45FB;
}
		

// -------------------------------------------
// Shared Enum Types
// -------------------------------------------

// --- Shared Enum Types --


// -------------------------------------------
// Shared Struct Types
// -------------------------------------------

// --- Shared Struct Types --

}

// ------------------ end of SharedTypes.cs -----------------
#endregion



#region ComponentData
// -----------------------------------
//  ComponentData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	
	
 
	
	
 
	
	
	// EcsComponentData: InternalLocalUserData
	public struct LocalUser : IComponentData
	{
		public int localIndex;
	}
	
	
	
	// EcsComponentData: InternalWorldPositionQueryData
	public struct WorldPositionQuery : IComponentData
	{
		public float3 position;
		public float radius;
	}
	
	
	
	// EcsComponentData: InternalCoherenceSessionComponentData
	public struct CoherenceSessionComponent : IComponentData
	{
	}
	
	
	
	// EcsComponentData: InternalPlayerData
	public struct Player : IComponentData
	{
	}
	
	
	
	// EcsComponentData: InternalShotData
	public struct Shot : IComponentData
	{
		public Entity Owner;
	}
	
	

}


// ------------------ end of ComponentData.cs -----------------
#endregion



#region BufferElementData
// -----------------------------------
//  BufferElementData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	


}


// ------------------ end of BufferElementData.cs -----------------
#endregion



#region SerializeCreateEntity
// -----------------------------------
//  SerializeCreateEntity.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Message.Serializer.Serialize;
    using Piot.Log;
    using Unity.Entities;
    using Unity.Transforms;
    using IOutBitStream = Piot.Brook.IOutBitStream;
    using global::Coherence.Generated.FirstProject;
    using Coherence.Replication.Unity;

    public class SerializeCreateEntityRequest
    {
        private MessageSerializers messageSerializers;

        public SerializeCreateEntityRequest(UnityMapper mapper)
        {
            messageSerializers = new MessageSerializers(mapper);
        }
        
        public void SerializeComponentsInMessageFormat(EntityManager entityManager,
            Entity entity, uint[] foundComponentTypes, IOutBitStream bitStream, ILog log)
        {
            var protocolOutStream = new FieldStream.Serialize.Streams.OutBitStream(bitStream, log);

            foreach (var coherenceComponentType in foundComponentTypes)
            {
				ComponentTypeIdSerializer.Serialize(coherenceComponentType, bitStream);

				switch (coherenceComponentType)
                {
					
                    case TypeIds.InternalWorldPositionComponent:
					{
						var data = entityManager.GetComponentData<Translation>(entity);
						messageSerializers.WorldPositionComponent(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalWorldOrientationComponent:
					{
						var data = entityManager.GetComponentData<Rotation>(entity);
						messageSerializers.WorldOrientationComponent(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalLocalUser:
					{
						var data = entityManager.GetComponentData<LocalUser>(entity);
						messageSerializers.LocalUser(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalWorldPositionQuery:
					{
						var data = entityManager.GetComponentData<WorldPositionQuery>(entity);
						messageSerializers.WorldPositionQuery(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalCoherenceSessionComponent:
					{
						var data = entityManager.GetComponentData<CoherenceSessionComponent>(entity);
						messageSerializers.CoherenceSessionComponent(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalPlayer:
					{
						var data = entityManager.GetComponentData<Player>(entity);
						messageSerializers.Player(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalShot:
					{
						var data = entityManager.GetComponentData<Shot>(entity);
						messageSerializers.Shot(protocolOutStream, data);
						break;
					}
					

                    default:
                    {
                        log.Warning($"Unknown component", "component", coherenceComponentType);
                        break;
                    }
                }
            }
        }
    }
}

// ------------------ end of SerializeCreateEntity.cs -----------------
#endregion



#region DeserializeComponentUpdate
// -----------------------------------
//  DeserializeComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.Brook;
    using Piot.Log;
	using Unity.Entities;
	using Unity.Transforms;
    using DeltaEcs;
    using global::Coherence.Generated.FirstProject;
    using Piot.SimulationFrame;
    using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class DeserializeComponentUpdateGenerated
    {
        private UnityReaders unityReaders;

        public DeserializeComponentUpdateGenerated(UnityMapper mapper)
        {
            unityReaders = new UnityReaders(mapper);
        }


        private void DeserializeWorldPositionComponent(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Translation();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Ensure entities with interpolation also have Interpolation components and Sample components
			if (!entityManager.HasComponent<InterpolationComponent_Translation>(entity))
			{
				entityManager.AddComponent<InterpolationComponent_Translation>(entity);
				entityManager.AddComponent<Sample_Translation>(entity);
			}

			// Append buffer for components that use interpolation
			var tempComponentData = new Translation();
			unityReaders.Read(ref tempComponentData, protocolStream);
			if (justCreated) // Hack
			{
				entityManager.SetComponentData(entity, tempComponentData);
			}
			InterpolationSystem_Translation.AppendBuffer(entity, tempComponentData, entityManager.World, (ulong) simulationFrame.Frame);
    

		}

        private void DeserializeWorldOrientationComponent(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Rotation();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Ensure entities with interpolation also have Interpolation components and Sample components
			if (!entityManager.HasComponent<InterpolationComponent_Rotation>(entity))
			{
				entityManager.AddComponent<InterpolationComponent_Rotation>(entity);
				entityManager.AddComponent<Sample_Rotation>(entity);
			}

			// Append buffer for components that use interpolation
			var tempComponentData = new Rotation();
			unityReaders.Read(ref tempComponentData, protocolStream);
			if (justCreated) // Hack
			{
				entityManager.SetComponentData(entity, tempComponentData);
			}
			InterpolationSystem_Rotation.AppendBuffer(entity, tempComponentData, entityManager.World, (ulong) simulationFrame.Frame);
    

		}

        private void DeserializeLocalUser(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new LocalUser();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<LocalUser>(entity);
			unityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);
    

		}

        private void DeserializeWorldPositionQuery(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new WorldPositionQuery();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<WorldPositionQuery>(entity);
			unityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);
    

		}

        private void DeserializeCoherenceSessionComponent(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

			// No need to read empty components, just ensure that it's there
            if (!entityManager.HasComponent<CoherenceSessionComponent>(entity))
		    {
				entityManager.AddComponent<CoherenceSessionComponent>(entity);
			}

		}

        private void DeserializePlayer(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

			// No need to read empty components, just ensure that it's there
            if (!entityManager.HasComponent<Player>(entity))
		    {
				entityManager.AddComponent<Player>(entity);
			}

		}

        private void DeserializeShot(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Shot();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<Shot>(entity);
			unityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);
    

		}

        

        public void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, false, log);
		}

        public void ReadComponentDataUpdateEx(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, bool justCreated, ILog log)
        {
            var componentOwnership = Deserializator.ReadComponentOwnership(bitStream, log); // Read bit from stream...
            componentOwnership = entityManager.HasComponent<CoherenceSimulateComponent>(entity); // Then overwrite it with entity ownership.
            var inProtocolStream = new Coherence.FieldStream.Deserialize.Streams.InBitStream(bitStream, log);
            switch (componentType)
            {
				
			case TypeIds.InternalWorldPositionComponent:
				DeserializeWorldPositionComponent(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalWorldOrientationComponent:
				DeserializeWorldOrientationComponent(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalLocalUser:
				DeserializeLocalUser(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalWorldPositionQuery:
				DeserializeWorldPositionQuery(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalCoherenceSessionComponent:
				DeserializeCoherenceSessionComponent(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalPlayer:
				DeserializePlayer(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalShot:
				DeserializeShot(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				

			default:
				log.Warning("couldn't find component", "componentType", componentType);
				break;
			}
		}
		
        public void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
#region Commands

#endregion

            switch (componentType)
            {

				case TypeIds.InternalWorldPositionComponent:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Translation>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPositionComponent_Sync>(entity) && entityManager.GetComponentData<WorldPositionComponent_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Translation());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalWorldOrientationComponent:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Rotation>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldOrientationComponent_Sync>(entity) && entityManager.GetComponentData<WorldOrientationComponent_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Rotation());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalLocalUser:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<LocalUser_Sync>(entity) && entityManager.GetComponentData<LocalUser_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new LocalUser());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalWorldPositionQuery:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPositionQuery_Sync>(entity) && entityManager.GetComponentData<WorldPositionQuery_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new WorldPositionQuery());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalCoherenceSessionComponent:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity) && entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new CoherenceSessionComponent());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalPlayer:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Player>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<Player_Sync>(entity) && entityManager.GetComponentData<Player_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Player());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalShot:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Shot>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<Shot_Sync>(entity) && entityManager.GetComponentData<Shot_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Shot());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

                default:
				{
                    log.Warning("can not create component type");
                    break;
				}
            }
        }		
    }

    public class ComponentDeserializeWrapper : ISchemaSpecificComponentDeserialize
    {
        private DeserializeComponentUpdateGenerated deserializeComponentUpdateGenerated;

        public ComponentDeserializeWrapper(UnityMapper mapper)
        {
            deserializeComponentUpdateGenerated = new DeserializeComponentUpdateGenerated(mapper);
        }

        public void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            deserializeComponentUpdateGenerated.CreateIfNeededAndReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }

        public void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            deserializeComponentUpdateGenerated.ReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }
    }

}

// ------------------ end of DeserializeComponentUpdate.cs -----------------
#endregion



#region DeserializeAndSkipComponentUpdate
// -----------------------------------
//  DeserializeAndSkipComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.Log;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;
    using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class DeserializeComponentUpdateSkipGenerated
    {
        private UnityReaders unityReaders;

        public DeserializeComponentUpdateSkipGenerated(UnityMapper mapper)
        {
            unityReaders = new UnityReaders(mapper);
        }

		
		private void DeserializeWorldPositionComponent(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Translation();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeWorldOrientationComponent(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Rotation();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeLocalUser(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new LocalUser();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeWorldPositionQuery(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new WorldPositionQuery();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeCoherenceSessionComponent(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new CoherenceSessionComponent();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializePlayer(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Player();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeShot(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Shot();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
 
		public void SkipComponentDataUpdate(uint componentType, Coherence.Replication.Protocol.Definition.IInBitStream inProtocolStream, ILog log)
        {
			switch (componentType)
            {

                case TypeIds.InternalWorldPositionComponent:
					DeserializeWorldPositionComponent(inProtocolStream);
                    break;

                case TypeIds.InternalWorldOrientationComponent:
					DeserializeWorldOrientationComponent(inProtocolStream);
                    break;

                case TypeIds.InternalLocalUser:
					DeserializeLocalUser(inProtocolStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
					DeserializeWorldPositionQuery(inProtocolStream);
                    break;

                case TypeIds.InternalCoherenceSessionComponent:
					DeserializeCoherenceSessionComponent(inProtocolStream);
                    break;

                case TypeIds.InternalPlayer:
					DeserializePlayer(inProtocolStream);
                    break;

                case TypeIds.InternalShot:
					DeserializeShot(inProtocolStream);
                    break;

			}
		}
    }
    
    public class DeserializeComponentsAndSkipWrapper : ISchemaSpecificComponentDeserializerAndSkip
    {
        DeserializeComponentUpdateSkipGenerated deserializeComponentUpdateSkipGenerated;

        public DeserializeComponentsAndSkipWrapper(UnityMapper mapper)
        {
            deserializeComponentUpdateSkipGenerated = new DeserializeComponentUpdateSkipGenerated(mapper);
        }

        public void DeserializeAndSkipComponent(uint componentTypeId, Coherence.Replication.Protocol.Definition.IInBitStream protocolOutStream, ILog log)
        {
            deserializeComponentUpdateSkipGenerated.SkipComponentDataUpdate(componentTypeId, protocolOutStream, log);
        }
    }    
}

// ------------------ end of DeserializeAndSkipComponentUpdate.cs -----------------
#endregion



#region SyncReceiveSystem
// -----------------------------------
//  SyncReceiveSystem.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Piot.SimulationFrame;
    using Protocol.Deserialize;
    using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Sdk.Unity;

    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(InitializationSystemGroup))]
    [AlwaysUpdateSystem]
    public class SyncReceiveSystem : SystemBase
    {
        private Receiver receiver;
        CoherenceSimulationSystemGroup simGroup;
        private bool hasInitialTime;
        private bool isBooted;

        private void BootUp()
        {
	        simGroup = World.GetExistingSystem<CoherenceSimulationSystemGroup>();
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
            var deserializeComponents = new ComponentDeserializeWrapper(netSys.Mapper);
            var skipper = new DeserializeComponentsAndSkipWrapper(netSys.Mapper);
            var commandPerform = new PerformCommands(netSys.Mapper);
            var receiveUpdate = new ReceiveUpdate(deserializeComponents, skipper, netSys.Mapper, netSys.DestroyedEntities, netSys.Log);
            receiver = new Receiver(World, netSys.Mapper, netSys.Connector, receiveUpdate, commandPerform, netSys.SentPacketsCache, netSys.Log);
        }

        private void ChangeClockSpeed(ClockSpeedFactor factor)
        {
            const float desiredTimestep = 1f / 60f;
            var timeStep = 0f;
            if (factor.FactorTimesThousand <= 1)
            {
            }
            else
            {
	            timeStep = desiredTimestep * 1000f / factor.FactorTimesThousand;
            }

            simGroup.SetTimeStep(true, timeStep, 0);
        }

        protected override void OnUpdate()
        {
	        if (!isBooted)
	        {
		        isBooted = true;
		        BootUp();
	        }

            // Respond to network disconnect events
	        Entities.ForEach((in DisconnectedEvent connected) =>
	        {
		        // Destroy all networked entities 
		        World.GetOrCreateSystem<NetworkSystem>().Mapper.ClearAndDestroyEntities();
		        
		        // Clear the incoming packet repository
		        receiver.ResetPacketRepository();
	        }).WithStructuralChanges().WithoutBurst().Run();

            var simulationFrame = new AbsoluteSimulationFrame { Frame = (long)simGroup.SimulationFrame };
            var adjust = receiver.OnUpdate(simulationFrame);

            if (adjust.State != SpecialCommandState.Ignore)
	        {
	            var needsToOverwriteTime = (!hasInitialTime && adjust.SimulationFrame.Frame != 0) || adjust.State == SpecialCommandState.Reset;

	            if (needsToOverwriteTime)
	            {
	                simGroup.SetSimulationFrame((ulong)adjust.SimulationFrame.Frame);
	                hasInitialTime = true;
	            }

	            ChangeClockSpeed(adjust.ClockSpeed);
            }
        }
    }
}

// ------------------ end of SyncReceiveSystem.cs -----------------
#endregion



#region SyncComponent
// -----------------------------------
//  SyncComponent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Unity.Entities;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;


    public struct WorldPositionComponent_Sync : IComponentData
    {
        public Translation lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct WorldOrientationComponent_Sync : IComponentData
    {
        public Rotation lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct LocalUser_Sync : IComponentData
    {
        public LocalUser lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct WorldPositionQuery_Sync : IComponentData
    {
        public WorldPositionQuery lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct CoherenceSessionComponent_Sync : IComponentData
    {
        public CoherenceSessionComponent lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct Player_Sync : IComponentData
    {
        public Player lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct Shot_Sync : IComponentData
    {
        public Shot lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


}


// ------------------ end of SyncComponent.cs -----------------
#endregion



#region SerializeComponentUpdate
// -----------------------------------
//  SerializeComponentUpdate.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using System;
	using Unity.Entities;
	using Unity.Transforms;
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Protocol.Definition;
	using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class SerializeComponentUpdatesGenerated
    {
         private UnityWriters unityWriters;

         public SerializeComponentUpdatesGenerated(UnityMapper mapper)
         {
             unityWriters = new UnityWriters(mapper);
         }


        private void SerializeWorldPositionComponent(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Translation>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPositionComponent_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeWorldOrientationComponent(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Rotation>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldOrientationComponent_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeLocalUser(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<LocalUser>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<LocalUser_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeWorldPositionQuery(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<WorldPositionQuery>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeCoherenceSessionComponent(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializePlayer(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<Player_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeShot(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Shot>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<Shot_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

    
        public void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint componentType, uint fieldMask, IOutBitStream protocolOutStream)
        {
            switch (componentType)
            {

                case TypeIds.InternalWorldPositionComponent:
                    SerializeWorldPositionComponent(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalWorldOrientationComponent:
                    SerializeWorldOrientationComponent(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalLocalUser:
                    SerializeLocalUser(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
                    SerializeWorldPositionQuery(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalCoherenceSessionComponent:
                    SerializeCoherenceSessionComponent(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalPlayer:
                    SerializePlayer(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalShot:
                    SerializeShot(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                default:
                    throw new Exception($"unknown componentType {componentType}");
            }
        }
    
        
        public void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
        {
            switch (componentTypeId)
            {

                case TypeIds.InternalWorldPositionComponent:
                {
                    var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalWorldOrientationComponent:
                {
                    var syncData = entityManager.GetComponentData<WorldOrientationComponent_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var syncData = entityManager.GetComponentData<LocalUser_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalCoherenceSessionComponent:
                {
                    var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalPlayer:
                {
                    var syncData = entityManager.GetComponentData<Player_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalShot:
                {
                    var syncData = entityManager.GetComponentData<Shot_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }


                default:
                    throw new Exception($"unknown componentType {componentTypeId}");
            }
        }
    }
    
    class SerializeComponentUpdatesWrapper : ISchemaSpecificComponentSerializer
    {
        private SerializeComponentUpdatesGenerated serializeComponentUpdatesGenerated;

        public SerializeComponentUpdatesWrapper(UnityMapper mapper)
        {
            serializeComponentUpdatesGenerated = new SerializeComponentUpdatesGenerated(mapper);
        }

    	public void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint ComponentTypeId, uint fieldMask, IOutBitStream protocolOutStream)
    	{
    		serializeComponentUpdatesGenerated.SerializeComponent(entityManager, unityEntity, ComponentTypeId, fieldMask, protocolOutStream);
    	}
    	
    	public void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
    	{
            serializeComponentUpdatesGenerated.UpdateDestructState(entityManager, unityEntity, componentTypeId);
        }
    }

}


// ------------------ end of SerializeComponentUpdate.cs -----------------
#endregion



#region ComponentMaskDeserializers
// -----------------------------------
//  ComponentMaskDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Unity.Transforms;
	using Coherence.Replication.Unity;
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;


public class UnityReaders
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public UnityReaders(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }

	public uint Read(ref Translation data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
				 data = coherenceToUnityConverters.ToUnityTranslation(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
   
		return propertyMask;
	}

	public uint Read(ref Rotation data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadUnitRotation();
				 data = coherenceToUnityConverters.ToUnityRotation(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
   
		return propertyMask;
	}

	
	
	
	
	
	
	
	
	public uint Read(ref LocalUser data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadIntegerRange(15, -9999);
			       data.localIndex = coherenceField;
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	
	
	public uint Read(ref WorldPositionQuery data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
			     data.position = coherenceToUnityConverters.ToUnityfloat3(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadFixedPoint(24, 40000);
			     data.radius = coherenceToUnityConverters.ToUnityfloat(coherenceField);
			propertyMask |= 0b00000000000000000000000000000010;
		}
       
		return propertyMask;
	}

	
	
	
	public uint Read(ref CoherenceSessionComponent data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

       
		return propertyMask;
	}

	
	
	
	public uint Read(ref Player data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

       
		return propertyMask;
	}

	
	
	
	public uint Read(ref Shot data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

            if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadEntity();
			     data.Owner = coherenceToUnityConverters.ToUnityEntity(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	
}

}

// ------------------ end of ComponentMaskDeserializers.cs -----------------
#endregion



#region ComponentMaskSerializers
// -----------------------------------
//  ComponentMaskSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Replication.Unity;
	using Unity.Transforms;


	public class UnityWriters
	{
        private CoherenceToUnityConverters coherenceToUnityConverters;

        public UnityWriters(UnityMapper mapper)
        {
            coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
        }

		public void Write(in Translation data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{

			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = coherenceToUnityConverters.FromUnityTranslation(data);
					bitstream.WriteVector3f(v, 24, 2400);
				
			}
			propertyMask >>= 1;

	 }

		public void Write(in Rotation data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{

			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var q = coherenceToUnityConverters.FromUnityRotation(data);
					bitstream.WriteUnitRotation(q);
				
			}
			propertyMask >>= 1;

	 }

		
		
		
		
		
		
		
		
		
			public void Write(in LocalUser data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
					
				}
				propertyMask >>= 1;
	
	     }

		
		
		
		
			public void Write(in WorldPositionQuery data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						var v = coherenceToUnityConverters.FromUnityfloat3(data.position);
						bitstream.WriteVector3f(v, 24, 2400);
					
				}
				propertyMask >>= 1;
	
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						var v = coherenceToUnityConverters.FromUnityfloat(data.radius);
						bitstream.WriteFixedPoint(v, 24, 40000);
					
				}
				propertyMask >>= 1;
	
	     }

		
		
		
		
			public void Write(in CoherenceSessionComponent data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	     }

		
		
		
		
			public void Write(in Player data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	     }

		
		
		
		
			public void Write(in Shot data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
			{
	
				if (bitstream.WriteMask((propertyMask & 0x01) != 0))
				{
					
						var v = coherenceToUnityConverters.FromUnityEntity(data.Owner);
						bitstream.WriteEntity(v);
					
				}
				propertyMask >>= 1;
	
	     }

		
		
	}
}

// ------------------ end of ComponentMaskSerializers.cs -----------------
#endregion



#region MessageSerializers
// -----------------------------------
//  MessageSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;
	using Replication.Unity;


public class MessageSerializers
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public MessageSerializers(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }

	public void WorldPositionComponent(IOutBitStream bitstream, Translation data)
	{
		var internalData = coherenceToUnityConverters.FromUnityTranslation(data);
		bitstream.WriteVector3f(internalData, 24, 2400);
	}

	public void WorldOrientationComponent(IOutBitStream bitstream, Rotation data)
	{
		var internalData = coherenceToUnityConverters.FromUnityRotation(data);
		bitstream.WriteUnitRotation(internalData);
	}









	public void LocalUser(IOutBitStream bitstream, LocalUser data)
	{

			
				bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
			

	}



	public void WorldPositionQuery(IOutBitStream bitstream, WorldPositionQuery data)
	{

			
				var converted_position = coherenceToUnityConverters.FromUnityfloat3(data.position);
				bitstream.WriteVector3f(converted_position, 24, 2400);
			

			
				var converted_radius = coherenceToUnityConverters.FromUnityfloat(data.radius);
				bitstream.WriteFixedPoint(converted_radius, 24, 40000);
			

	}



	public void CoherenceSessionComponent(IOutBitStream bitstream, CoherenceSessionComponent data)
	{

	}



	public void Player(IOutBitStream bitstream, Player data)
	{

	}



	public void Shot(IOutBitStream bitstream, Shot data)
	{

			
				var converted_Owner = coherenceToUnityConverters.FromUnityEntity(data.Owner);
				bitstream.WriteEntity(converted_Owner);
			

	}



/// ------------------------ Requests --------------------------



}

}

// ------------------ end of MessageSerializers.cs -----------------
#endregion



#region MessageDeserializers
// -----------------------------------
//  MessageDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;	
	using Replication.Unity;


public class MessageDeserializers
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public MessageDeserializers(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }

	public void WorldPositionComponent(IInBitStream bitstream, ref Translation data)
	{
		var coherenceVector = bitstream.ReadVector3f(24, 2400);
		data = coherenceToUnityConverters.ToUnityTranslation(coherenceVector);
	}










	public void LocalUser(IInBitStream bitstream, ref LocalUser data)
	{

			
				data.localIndex =  bitstream.ReadIntegerRange(15, -9999);
			
     
	}



	public void WorldPositionQuery(IInBitStream bitstream, ref WorldPositionQuery data)
	{

			
				var position = bitstream.ReadVector3f(24, 2400);
				data.position = coherenceToUnityConverters.ToUnityfloat3(position);
			

			
				var radius = bitstream.ReadFixedPoint(24, 40000);
				data.radius = coherenceToUnityConverters.ToUnityfloat(radius);
			
     
	}



	public void CoherenceSessionComponent(IInBitStream bitstream, ref CoherenceSessionComponent data)
	{
     
	}



	public void Player(IInBitStream bitstream, ref Player data)
	{
     
	}



	public void Shot(IInBitStream bitstream, ref Shot data)
	{

			
				var Owner = bitstream.ReadEntity();
				data.Owner = coherenceToUnityConverters.ToUnityEntity(Owner);
			
     
	}



}

}

// ------------------ end of MessageDeserializers.cs -----------------
#endregion



#region CommandDeserializers
// -----------------------------------
//  CommandDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Piot.Log;
	using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;

	public class PerformCommands : IPerformCommand
	{
        private MessageDeserializers messageDeserializers;

         public PerformCommands(UnityMapper mapper)
         {
             messageDeserializers = new MessageDeserializers(mapper);
         }

		public void PerformCommand(EntityManager mgr, Entity entity, uint commandTypeID, Coherence.Replication.Protocol.Definition.IInBitStream bitStream, ILog log)
		{

		}
	}
}


// ------------------ end of CommandDeserializers.cs -----------------
#endregion



#region RuntimeSystem
// -----------------------------------
//  RuntimeSystem.cs
// -----------------------------------
			
namespace Coherence.Sdk.Unity
{
	using Coherence.Generated.Internal.FirstProject;
	using global::Unity.Entities;
	using global::Unity.Transforms;
	using Piot.Log;
	using Replication.Client.Unity.Ecs;
	using global::Coherence.Generated.FirstProject;

	[UpdateInGroup(typeof(SimulationSystemGroup))]
	public class CoherenceRuntimeSystem : ComponentSystem
	{
		protected override void OnCreate()
		{
			#region Register all known component types and their enums
			           GlobalLookups.Register<Translation>(TypeEnums.InternalWorldPositionComponent);
           GlobalLookups.Register<Rotation>(TypeEnums.InternalWorldOrientationComponent);
           GlobalLookups.Register<LocalUser>(TypeEnums.InternalLocalUser);
           GlobalLookups.Register<WorldPositionQuery>(TypeEnums.InternalWorldPositionQuery);
           GlobalLookups.Register<CoherenceSessionComponent>(TypeEnums.InternalCoherenceSessionComponent);
           GlobalLookups.Register<Player>(TypeEnums.InternalPlayer);
           GlobalLookups.Register<Shot>(TypeEnums.InternalShot);

			#endregion

			#region Register all known component types and their component type id
			           GlobalTypeIdLookups.Register<Translation>(TypeIds.InternalWorldPositionComponent);
           GlobalTypeIdLookups.Register<Rotation>(TypeIds.InternalWorldOrientationComponent);
           GlobalTypeIdLookups.Register<LocalUser>(TypeIds.InternalLocalUser);
           GlobalTypeIdLookups.Register<WorldPositionQuery>(TypeIds.InternalWorldPositionQuery);
           GlobalTypeIdLookups.Register<CoherenceSessionComponent>(TypeIds.InternalCoherenceSessionComponent);
           GlobalTypeIdLookups.Register<Player>(TypeIds.InternalPlayer);
           GlobalTypeIdLookups.Register<Shot>(TypeIds.InternalShot);

			#endregion

			base.OnCreate();
		}

		protected override void OnUpdate()
		{
		}
	}
}

// ------------------ end of RuntimeSystem.cs -----------------
#endregion



#region DetectEntityCreateAndDestroy
// -----------------------------------
//  DetectEntityCreateAndDestroy.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Replication.Client.Unity.Ecs;
	using Unity.Collections;
    using Unity.Entities;
    using Replication.Unity;
    using Unity.Transforms;
    using UnityEngine;    
    
    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(SyncSendSystem))]
    public class DetectEntityCreateSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            if (World.GetExistingSystem<SyncSendSystem>().Sender == null)
            {
                Debug.LogWarning("No sender");
                return;
            }
            var mapper = World.GetExistingSystem<SyncSendSystem>().Sender.Mapper;
            
            Entities.WithNone<CoherenceMappedComponent>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponent simulate) =>
            {
                var id = mapper.NextEntityId;
                mapper.Add(id, entity);
                EntityManager.AddComponent<CoherenceMappedComponent>(entity);
            }).WithStructuralChanges().WithoutBurst().Run();

            Dependency.Complete();
       }
    }
} // namespace
        


// ------------------ end of DetectEntityCreateAndDestroy.cs -----------------
#endregion



#region DetectCommandSent
// -----------------------------------
//  DetectCommandSent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using UnityEngine;
    using Unity.Entities;
    using global::Coherence.Generated.FirstProject;

    using Message;
    using Message.Serializer.Serialize;
    using Piot.Brisk.Connect;
    using Piot.Brook;
    using Piot.Log;
    using Replication.Client.Unity.Ecs;
    using Replication.Unity;

   // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [AlwaysUpdateSystem]
    public class DetectCommandsSentSystem : SystemBase
    {
        private bool isBooted;
	    private Sender cachedSender;
		private MessageSerializers messageSerializers;

        void BootUp()
        {
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
			messageSerializers = new MessageSerializers(netSys.Mapper);
        }

	    protected override void OnUpdate()
	    {
	        if (!isBooted)
	        {
		        BootUp();
		        isBooted = true;
	        }

		    if (cachedSender == null)
		    {
			    cachedSender = World.GetExistingSystem<SyncSendSystem>().Sender;
			    if (cachedSender == null)
			    {
				    return;
			    }
            }

	        var log = new Log(new UnityLogger(LogLevel.Debug));

	        var burstSender = cachedSender;
	        var mapper = cachedSender.Mapper;



        }
    }

}


// ------------------ end of DetectCommandSent.cs -----------------
#endregion



#region RecieveUpdate
// -----------------------------------
//  RecieveUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Ecs;
	using Coherence.DeltaEcs;
	using Coherence.Replication.Unity;
	using Coherence.Replication.Client.Unity.Ecs;
	using global::Unity.Transforms;
	using global::Unity.Collections;
	using global::Unity.Entities;
	using Piot.Brook;
	using Piot.Log;
	using Piot.SimulationFrame;
	using global::Coherence.Generated.FirstProject;

	public class ReceiveUpdate : IReceiveUpdate
	{
		private readonly ISchemaSpecificComponentDeserialize componentDeserialize;
		private readonly ILog log;
		private UnityMapper mapper;
		private readonly ISchemaSpecificComponentDeserializerAndSkip componentSkip;
		private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;

		public ReceiveUpdate(ISchemaSpecificComponentDeserialize componentDeserialize,  ISchemaSpecificComponentDeserializerAndSkip componentSkip, UnityMapper mapper, NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities, ILog log)
		{
			this.componentDeserialize = componentDeserialize;
			this.componentSkip = componentSkip;
			this.mapper = mapper;
			this.log = log;
			this.destroyedEntities = destroyedEntities;
		}

		private void DestroyComponentData(EntityManager entityManager, Entity entity, uint componentType)
		{
			switch (componentType)
			{

				case TypeIds.InternalWorldPositionComponent:
				{
					var hasComponentData = entityManager.HasComponent<Translation>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Translation>(entity);
					}
					break;
				}

				case TypeIds.InternalWorldOrientationComponent:
				{
					var hasComponentData = entityManager.HasComponent<Rotation>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Rotation>(entity);
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<LocalUser>(entity);
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<WorldPositionQuery>(entity);
					}
					break;
				}

				case TypeIds.InternalCoherenceSessionComponent:
				{
					var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<CoherenceSessionComponent>(entity);
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Player>(entity);
					}
					break;
				}

				case TypeIds.InternalShot:
				{
					var hasComponentData = entityManager.HasComponent<Shot>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Shot>(entity);
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentType);
					break;
				}
			}
		}

		private void UpdateComponents(EntityManager entityManager, Entity entity, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
		{
			var componentCount = Deserializator.ReadComponentCount(bitStream, log);
			for (var i = 0; i < componentCount; i++)
			{
				var componentState = Deserializator.ReadComponentState(bitStream, log);
				var componentId = Deserializator.ReadComponentId(bitStream, log);
				switch (componentState)
				{
					case ComponentState.Construct:
						{
							var componentTypeId = Deserializator.ReadComponentTypeId(bitStream, log);

							componentDeserialize.CreateIfNeededAndReadComponentDataUpdate(entityManager,
								entity, componentTypeId, simulationFrame, bitStream, log);
						}
						break;
					case ComponentState.Update:
						{
							// TODO: lookup component ID from state.
							var updateComponentTypeId = componentId;
							componentDeserialize.ReadComponentDataUpdate(entityManager, entity,
								updateComponentTypeId, simulationFrame, bitStream, log);
						}
						break;
					case ComponentState.Destruct:
						{
							var destroyComponentTypeId = componentId;
							DestroyComponentData(entityManager, entity, destroyComponentTypeId);
						}
						break;
				}
			}
		}

		public void PerformUpdate(EntityManager entityManager, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
		{
			var deserializeEntity = new Deserializator();

			while (deserializeEntity.ReadEntity(bitStream, out var entityWithMeta, log))
			{
				var entity = mapper.ToUnityEntity(entityWithMeta.EntityId, false);

				// Skip locally destroyed entities
				if (destroyedEntities.ContainsKey(entity))
				{
					if (!entityWithMeta.IsDeleted)
					{
						DeserializeComponentSkip.SkipComponents(componentSkip, bitStream, log);
					}
					continue;
				}

				// Meta information concerns entity creation, destruction and ownership
				if (entityWithMeta.HasMeta)
				{
					entity = PerformEntityMetaUpdate(entityManager, entityWithMeta, entity);
				}

				// Deserialize and apply component updates
				if (entity != default)
				{
					if (entityManager.HasComponent<CoherenceSimulateComponent>(entity))
					{
						DeserializeComponentSkip.SkipComponents(componentSkip, bitStream, log);
						log.Warning($"Trying to update owned entity {entityWithMeta.EntityId}");
					}
					else
					{
						UpdateComponents(entityManager, entity, simulationFrame, bitStream);
					}
				} else if (!entityWithMeta.IsDeleted)
				{
					// An error has occurred if the entity is null unless it's because it was just deleted
					log.Warning($"Entity is missing {entityWithMeta.EntityId}");
				}
			}
		}

		private Entity PerformEntityMetaUpdate(EntityManager entityManager, Deserializator.EntityWithMeta entityWithMeta, Entity entity)
		{
			// Entities are CREATED implicitly if they do not exist
			if (entity == default || !entityManager.Exists(entity))
			{
				if (entity != default)
				{
					UnityEngine.Debug.LogWarning("entity might still be mapped: " + entity + " CID: " + entityWithMeta.EntityId);
				}
				if (mapper.IsEntityIdInUse(entityWithMeta.EntityId))
				{
					UnityEngine.Debug.LogWarning("entity index already in use: " + entityWithMeta.EntityId);
					return default;
				}
				entity = entityManager.CreateEntity();
				mapper.Add(entityWithMeta.EntityId, entity);
				entityManager.AddComponent<CoherenceMappedComponent>(entity);
			}

			// Entities OWNERSHIP determines iff they should have CoherenceSimulateComponent
			var hasComponentData = entityManager.HasComponent<CoherenceSimulateComponent>(entity);
			if (hasComponentData && !entityWithMeta.Ownership)
			{
				entityManager.RemoveComponent<CoherenceSimulateComponent>(entity);
				entityManager.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
				RemoveSyncComponents(entityManager, entity);
			}
			else if (!hasComponentData && entityWithMeta.Ownership)
			{
				entityManager.AddComponentData(entity, new CoherenceSimulateComponent());
				RemoveInterpolationComponents(entityManager, entity);
			}

			// Entities are DELETED explicitly by the IsDeleted flag
			if (entityWithMeta.IsDeleted)
			{
				if (!entityWithMeta.Ownership)
				{
					log.Debug($"Deleting entity {entityWithMeta.Ownership} {entityWithMeta.EntityId}");
					if (entity != default)
					{
						if (entityManager.Exists(entity))
						{
							mapper.Remove(entityWithMeta.EntityId); // This internally requires entity to exist...
							entityManager.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
							entityManager.DestroyEntity(entity);    // ...so this must be executed afterwards ...
						}
						else
						{
							log.Warning($"Entity has already been deleted: {entityWithMeta.EntityId} : {entity}");
						}
					}
					else
					{
						log.Warning($"Attempted to delete missing entity: {entityWithMeta.EntityId}");
					}
				}
				else
				{
					log.Warning($"Attempted to delete owned entity: {entityWithMeta.EntityId}");
				}

				return default;
			}

			return entity;
		}

		public void UpdateResendMask(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, uint componentTypeId, uint fieldMask)
		{
			var entity = mapper.ToUnityEntity(entityId);

			switch (componentTypeId)
			{

				case TypeIds.InternalWorldPositionComponent:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalWorldOrientationComponent:
				{
					var hasComponentData = entityManager.HasComponent<WorldOrientationComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldOrientationComponent_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalCoherenceSessionComponent:
				{
					var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Player_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalShot:
				{
					var hasComponentData = entityManager.HasComponent<Shot_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Shot_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentTypeId);
					break;
				}
			}
		}

		public void UpdateHasReceivedConstructor(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, uint componentTypeId)
		{
			var entity = mapper.ToUnityEntity(entityId, false);

			// The entity has been deleted since the packet was sent
			if (destroyedEntities.ContainsKey(entity))
			{
				return;
			}

			if (!entityManager.Exists(entity))
			{
				log.Warning($"Entity does not exist: {entity} ComponentTypeId: {componentTypeId}");
				return;
			}

			if (!entityManager.HasComponent<CoherenceSimulateComponent>(entity))
			{
				// Ownership may have been lost since the packet was sent
				log.Trace($"Entity is missing CoherenceSimulateComponent: {entity} ComponentTypeId: {componentTypeId}");
				return;
			}

			var sim = entityManager.GetComponentData<CoherenceSimulateComponent>(entity);
			sim.hasReceivedConstructor = true;

			switch (componentTypeId)
			{

				case TypeIds.InternalWorldPositionComponent:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionComponent_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldPositionComponent_Sync");
					}
					break;
				}

				case TypeIds.InternalWorldOrientationComponent:
				{
					var hasComponentData = entityManager.HasComponent<WorldOrientationComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldOrientationComponent_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldOrientationComponent_Sync");
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} LocalUser_Sync");
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldPositionQuery_Sync");
					}
					break;
				}

				case TypeIds.InternalCoherenceSessionComponent:
				{
					var hasComponentData = entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<CoherenceSessionComponent_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} CoherenceSessionComponent_Sync");
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Player_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} Player_Sync");
					}
					break;
				}

				case TypeIds.InternalShot:
				{
					var hasComponentData = entityManager.HasComponent<Shot_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Shot_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} Shot_Sync");
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentTypeId);
					break;
				}
			}
		}

		public void UpdateResendDestroyed(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, AbsoluteSimulationFrame simulationFrame)
		{
			var entity = mapper.ToUnityEntity(entityId, false);
			if (entity == default)
			{
				log.Warning($"Destroyed entity {entityId} missing from mapper");
				return;
			}

			// Flag this entity destruction to be resent
			destroyedEntities[entity] = new DetectedEntityDeletion { Entity = entity, simulationFrame = (ulong)simulationFrame.Frame, serialized = false };
		}

		private void RemoveSyncComponents(EntityManager entityManager, Entity entity)
		{

			if (entityManager.HasComponent<WorldPositionComponent_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldPositionComponent_Sync>(entity);
			}

			if (entityManager.HasComponent<WorldOrientationComponent_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldOrientationComponent_Sync>(entity);
			}

			if (entityManager.HasComponent<LocalUser_Sync>(entity))
			{
				entityManager.RemoveComponent<LocalUser_Sync>(entity);
			}

			if (entityManager.HasComponent<WorldPositionQuery_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldPositionQuery_Sync>(entity);
			}

			if (entityManager.HasComponent<CoherenceSessionComponent_Sync>(entity))
			{
				entityManager.RemoveComponent<CoherenceSessionComponent_Sync>(entity);
			}

			if (entityManager.HasComponent<Player_Sync>(entity))
			{
				entityManager.RemoveComponent<Player_Sync>(entity);
			}

			if (entityManager.HasComponent<Shot_Sync>(entity))
			{
				entityManager.RemoveComponent<Shot_Sync>(entity);
			}

		}

		private void RemoveInterpolationComponents(EntityManager entityManager, Entity entity)
		{


			if (entityManager.HasComponent<InterpolationComponent_Translation>(entity))
			{
				entityManager.RemoveComponent<InterpolationComponent_Translation>(entity);
			}
			if (entityManager.HasComponent<Sample_Translation>(entity))
			{
				entityManager.RemoveComponent<Sample_Translation>(entity);
			}



			if (entityManager.HasComponent<InterpolationComponent_Rotation>(entity))
			{
				entityManager.RemoveComponent<InterpolationComponent_Rotation>(entity);
			}
			if (entityManager.HasComponent<Sample_Rotation>(entity))
			{
				entityManager.RemoveComponent<Sample_Rotation>(entity);
			}












		}
	}
}
// ------------------ end of RecieveUpdate.cs -----------------
#endregion



#region DynamicBufferData
// -----------------------------------
//  DynamicBufferData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	

}


// ------------------ end of DynamicBufferData.cs -----------------
#endregion



#region EntityReplacer
// -----------------------------------
//  EntityReplacer.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Entities;
	using Unity.Transforms;
	using UnityEngine;
	using Coherence.Replication.Client.Unity.Ecs;

	public class EntityReplacer {
		public static void Replace(EntityManager entityManager, Entity networkEntity, Entity newEntity)
		{
#if UNITY_EDITOR
			entityManager.SetName(newEntity, $"{networkEntity} (remote)");
#endif

			CopyComponents(entityManager, networkEntity, newEntity);

			var mapper = entityManager.World.GetExistingSystem<SyncSendSystem>().Sender.Mapper;
			if (!mapper.ToCoherenceEntityId(networkEntity, out var entityId))
			{
				Debug.LogError("Networked Entity not found in mapper: " + networkEntity); // Should not happen
			}

			mapper.Remove(entityId);
			mapper.Add(entityId, newEntity);
			entityManager.DestroyEntity(networkEntity);

			Debug.Log(string.Format("Replaced networked Entity {0} with new Entity {1}.", networkEntity, newEntity));
		}

		private static void CopyComponents(EntityManager entityManager, Entity source, Entity destination)
		{
		
            if(entityManager.HasComponent<Translation>(source))
			{
		        // Translation is built in
                var data = entityManager.GetComponentData<Translation>(source);
                entityManager.SetComponentData<Translation>(destination, data);
		
			}
		
            if(entityManager.HasComponent<Rotation>(source))
			{
		        // Rotation is built in
                var data = entityManager.GetComponentData<Rotation>(source);
                entityManager.SetComponentData<Rotation>(destination, data);
		
			}
		
            if(entityManager.HasComponent<LocalUser>(source))
			{
		        // LocalUser has fields, will copy it.			
                if(!entityManager.HasComponent<LocalUser>(destination)) {
                    entityManager.AddComponentData<LocalUser>(destination, new LocalUser());
                }
				var data = entityManager.GetComponentData<LocalUser>(source);
				entityManager.SetComponentData<LocalUser>(destination, data);
		
			}
		
            if(entityManager.HasComponent<WorldPositionQuery>(source))
			{
		        // WorldPositionQuery has fields, will copy it.			
                if(!entityManager.HasComponent<WorldPositionQuery>(destination)) {
                    entityManager.AddComponentData<WorldPositionQuery>(destination, new WorldPositionQuery());
                }
				var data = entityManager.GetComponentData<WorldPositionQuery>(source);
				entityManager.SetComponentData<WorldPositionQuery>(destination, data);
		
			}
		
            if(entityManager.HasComponent<CoherenceSessionComponent>(source))
			{
		        // CoherenceSessionComponent has no fields, will just add it.
		        entityManager.AddComponentData<CoherenceSessionComponent>(destination, new CoherenceSessionComponent());
		
			}
		
            if(entityManager.HasComponent<Player>(source))
			{
		        // Player has no fields, will just add it.
		        entityManager.AddComponentData<Player>(destination, new Player());
		
			}
		
            if(entityManager.HasComponent<Shot>(source))
			{
		        // Shot has fields, will copy it.			
                if(!entityManager.HasComponent<Shot>(destination)) {
                    entityManager.AddComponentData<Shot>(destination, new Shot());
                }
				var data = entityManager.GetComponentData<Shot>(source);
				entityManager.SetComponentData<Shot>(destination, data);
		
			}
		

        // Command buffers
        

		}
	}
}


// ------------------ end of EntityReplacer.cs -----------------
#endregion



#region DetectAddedComponent
// -----------------------------------
//  DetectAddedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Client.Unity.Ecs;
	using Unity.Entities;
	using Unity.Transforms;

	[UpdateInGroup(typeof(PresentationSystemGroup))]
	[UpdateBefore(typeof(DetectRemovedComponentsSystem))]
    public class DetectAddedComponentsSystem : SystemBase
    {
        protected override void OnUpdate()
        {

            Entities.WithAll<Translation, CoherenceSimulateComponent>().WithNone<WorldPositionComponent_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldPositionComponent_Sync 
				{
					howImportantAreYou = 1000
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<Rotation, CoherenceSimulateComponent>().WithNone<WorldOrientationComponent_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldOrientationComponent_Sync 
				{
					howImportantAreYou = 1000
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.LocalUser, CoherenceSimulateComponent>().WithNone<LocalUser_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new LocalUser_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.WorldPositionQuery, CoherenceSimulateComponent>().WithNone<WorldPositionQuery_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldPositionQuery_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.CoherenceSessionComponent, CoherenceSimulateComponent>().WithNone<CoherenceSessionComponent_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new CoherenceSessionComponent_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.Player, CoherenceSimulateComponent>().WithNone<Player_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new Player_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.Shot, CoherenceSimulateComponent>().WithNone<Shot_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new Shot_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectAddedComponent.cs -----------------
#endregion



#region DetectChangedComponent
// -----------------------------------
//  DetectChangedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;
	using Unity.Entities;
	using Unity.Transforms;

	[UpdateInGroup(typeof(PresentationSystemGroup))]
	[UpdateBefore(typeof(SyncSendSystem))]
    public class DetectChangedComponentsSystem : SystemBase
    {
	    protected override void OnUpdate()
	    {
		    var componentChanges = World.GetExistingSystem<SyncSendSystem>().ComponentChanges;
		    var localComponentChanges = componentChanges.AsParallelWriter();


			Entities.ForEach((Entity entity, ref WorldPositionComponent_Sync sync, in Translation data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.Value.Equals(sync.lastSentData.Value) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPositionComponent,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref WorldOrientationComponent_Sync sync, in Rotation data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.Value.Equals(sync.lastSentData.Value) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldOrientationComponent,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref LocalUser_Sync sync, in global::Coherence.Generated.FirstProject.LocalUser data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (data.localIndex != sync.lastSentData.localIndex) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalLocalUser,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in global::Coherence.Generated.FirstProject.WorldPositionQuery data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.position.Equals(sync.lastSentData.position) ) mask |= 0b00000000000000000000000000000001;



                if (data.radius != sync.lastSentData.radius) mask |= 0b00000000000000000000000000000010;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPositionQuery,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref CoherenceSessionComponent_Sync sync, in global::Coherence.Generated.FirstProject.CoherenceSessionComponent data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalCoherenceSessionComponent,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref Player_Sync sync, in global::Coherence.Generated.FirstProject.Player data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalPlayer,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref Shot_Sync sync, in global::Coherence.Generated.FirstProject.Shot data, in CoherenceSimulateComponent simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (data.Owner != sync.lastSentData.Owner) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalShot,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

		
			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectChangedComponent.cs -----------------
#endregion



#region DetectRemovedComponent
// -----------------------------------
//  DetectRemovedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence;
	using Coherence.Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;
	using Unity.Entities;
	using Unity.Transforms;

    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(DetectChangedComponentsSystem))]
    public class DetectRemovedComponentsSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            var simulationFrame = World.GetOrCreateSystem<CoherenceSimulationSystemGroup>().SimulationFrame;
			var componentChanges = World.GetExistingSystem<SyncSendSystem>().ComponentChanges;
			var localComponentChanges = componentChanges.AsParallelWriter();
			

			Entities.WithNone<Translation>().ForEach((Entity entity, ref WorldPositionComponent_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPositionComponent,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<Rotation>().ForEach((Entity entity, ref WorldOrientationComponent_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldOrientationComponent,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.LocalUser>().ForEach((Entity entity, ref LocalUser_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalLocalUser,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.WorldPositionQuery>().ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPositionQuery,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.CoherenceSessionComponent>().ForEach((Entity entity, ref CoherenceSessionComponent_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalCoherenceSessionComponent,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.Player>().ForEach((Entity entity, ref Player_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalPlayer,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.Shot>().ForEach((Entity entity, ref Shot_Sync sync, in CoherenceSimulateComponent sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalShot,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();


			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectRemovedComponent.cs -----------------
#endregion



#region DetectDeletedEntity
// -----------------------------------
//  DetectDeletedEntity.cs
// -----------------------------------
			
namespace Coherence.Replication.Client.Unity.Ecs
{
	using Coherence.Replication.Unity;
	using global::Unity.Collections;
	using global::Unity.Entities;
	
	[AlwaysUpdateSystem]
	[UpdateInGroup(typeof(PresentationSystemGroup))]
	public class DetectDeletedEntitiesSystem : SystemBase
	{
		private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;
		private bool booted;
		
		private void Boot()
		{
			destroyedEntities = World.GetExistingSystem<NetworkSystem>().DestroyedEntities;
			booted = false;
		}
		
		protected override void OnUpdate()
		{
			if (!booted)
			{
				Boot();
			}
			
			var simulationFrame = World.GetExistingSystem<CoherenceSimulationSystemGroup>().SimulationFrame;
			
			// Ensure all simulated entities have their system state component in order to track entity destruction
			Entities.WithNone<CoherenceSimulateComponentLinger>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponent simulate) =>
			{
				EntityManager.AddComponentData(entity, new CoherenceSimulateComponentLinger());
			}).WithStructuralChanges().WithoutBurst().Run();
			
			// Keep track of locally destroyed entities so that SyncReceiveSystem does not revive them
			var commandBuffer = World.GetExistingSystem<EndSimulationEntityCommandBufferSystem>().CreateCommandBuffer();
			Entities.WithNone<CoherenceSimulateComponent>().ForEach((Entity entity, int entityInQueryIndex, in CoherenceSimulateComponentLinger sync) =>
			{
				destroyedEntities.TryAdd(entity, new DetectedEntityDeletion { Entity = entity, simulationFrame = simulationFrame, serialized = false });
				commandBuffer.RemoveComponent<CoherenceSimulateComponentLinger>(entity);
			}).WithoutBurst().Run();
			
			// Clear entities that were locally destroyed over 10s ago, to prevent hashmap from overflowing  
			var kv = destroyedEntities.GetKeyValueArrays(Allocator.TempJob);
			for (var i = 0; i < kv.Values.Length; i++)
			{
				if (simulationFrame > kv.Values[i].simulationFrame + 60 * 10)
				{
					destroyedEntities.Remove(kv.Keys[i]);
				}
			}
			kv.Dispose();
		}
	}
}

// ------------------ end of DetectDeletedEntity.cs -----------------
#endregion



#region InjectSender
// -----------------------------------
//  InjectSender.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
    using Coherence.Replication.Client.Unity.Ecs;
    using Unity.Entities;

    [AlwaysUpdateSystem]
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(DetectDeletedEntitiesSystem))]
    public class InjectSenderSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            if (World.GetExistingSystem<SyncSendSystem>().Sender != null)
            {
                return;
            }
            
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
            var wrapper = new SerializeComponentUpdatesWrapper(netSys.Mapper);
            var sender = new Sender(World, netSys.Connector, netSys.Mapper, wrapper, netSys.SentPacketsCache, netSys.Log);
            World.GetExistingSystem<SyncSendSystem>().Sender = sender;
        }
    }
}
// ------------------ end of InjectSender.cs -----------------
#endregion
