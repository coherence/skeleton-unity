// <auto-generated>
// Generated file. DO NOT EDIT!
// Generated from schema 'FirstProject' [0x47D65F96]
// File created by coherence-code-generator development
// </auto-generated>



#region Shared
// -----------------------------------
//  Shared.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using System;
    using System.Collections.Generic;
	using Replication.Client.Unity.Ecs;


	

static class TypeIds
{
    // Note: The indexes of components/commands/events *should* start over from 0

	public const uint InternalWorldPosition = 0;

	public const uint InternalWorldOrientation = 1;

	public const uint InternalLocalUser = 2;

	public const uint InternalWorldPositionQuery = 3;

	public const uint InternalSessionBased = 4;

	public const uint InternalPlayer = 5;

	public const uint InternalDoit = 0;

}


enum TypeEnums
{

	InternalWorldPosition = 0,

	InternalWorldOrientation = 1,

	InternalLocalUser = 2,

	InternalWorldPositionQuery = 3,

	InternalSessionBased = 4,

	InternalPlayer = 5,

	InternalDoit = 0,

}


internal static class InternalGlobalLookups
{
	internal readonly static Dictionary<Type, TypeEnums> GlobalTypeToEnumLookup = new Dictionary<Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		GlobalTypeToEnumLookup.Add(typeof(T), e);
	}
}

internal static class GlobalLookups
{
	internal readonly static Dictionary<System.Type, TypeEnums> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, TypeEnums>();

	internal static TypeEnums Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static void Register<T>(TypeEnums e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

internal static class GlobalTypeIdLookups
{
	internal readonly static Dictionary<System.Type, uint> GlobalTypeToEnumLookup =
		new Dictionary<System.Type, uint>();

	internal static uint Lookup<T>()
	{
		return GlobalTypeToEnumLookup[typeof(T)];
	}

	internal static (uint, bool) LookupUsingType(System.Type t)
	{
		var foundIt = GlobalTypeToEnumLookup.TryGetValue(t, out var value);
		return !foundIt ? ((uint, bool)) (0, foundIt) : (value, true);
	}

	internal static void Register<T>(uint e)
	{
		if (!GlobalTypeToEnumLookup.ContainsKey(typeof(T))) {
			GlobalTypeToEnumLookup.Add(typeof(T), e);
		}
	}
}

class GlobalTypeIdLookupsWrapper : ITypeIdLookups
{
	public (uint, bool) LookupUsingType(Type t)
	{
		return GlobalTypeIdLookups.LookupUsingType(t);
	}
}

static class RleConstants
{
	public const uint EndOfComponentArray = 255;
	public const uint EndOfComponentIndex = 65535;
}




} // end of namespace


// ------------------ end of Shared.cs -----------------
#endregion



#region SharedTypes
// -----------------------------------
//  SharedTypes.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{

public static class Constants
{
	public const uint SchemaHash = 0x47D65F96;
}
		

// -------------------------------------------
// Shared Enum Types
// -------------------------------------------

// --- Shared Enum Types --


// -------------------------------------------
// Shared Struct Types
// -------------------------------------------

// --- Shared Struct Types --

}

// ------------------ end of SharedTypes.cs -----------------
#endregion



#region ComponentData
// -----------------------------------
//  ComponentData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	
	
 
	
	
 
	
	
	// EcsComponentData: InternalLocalUserData
	public struct LocalUser : IComponentData
	{
		public int localIndex;
	}
	
	
	
	// EcsComponentData: InternalWorldPositionQueryData
	public struct WorldPositionQuery : IComponentData
	{
		public float3 position;
		public float radius;
	}
	
	
	
	// EcsComponentData: InternalSessionBasedData
	public struct SessionBased : IComponentData
	{
	}
	
	
	
	// EcsComponentData: InternalPlayerData
	public struct Player : IComponentData
	{
	}
	
	

}


// ------------------ end of ComponentData.cs -----------------
#endregion



#region BufferElementData
// -----------------------------------
//  BufferElementData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	
	// EcsComponentData: InternalDoitData
	public struct Doit : IBufferElementData
	{
		public int number;
		public float fnum;
		public bool b;
		public float3 v3;
		public float2 v2;
		public quaternion rot;
		public Entity e;
		public FixedString64 text;
	}

	public struct DoitRequest : IBufferElementData
	{
		public int number;
		public float fnum;
		public bool b;
		public float3 v3;
		public float2 v2;
		public quaternion rot;
		public Entity e;
		public FixedString64 text;
	}

	


}


// ------------------ end of BufferElementData.cs -----------------
#endregion



#region SerializeCreateEntity
// -----------------------------------
//  SerializeCreateEntity.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Message.Serializer.Serialize;
    using Coherence.Log;
    using Unity.Entities;
    using Unity.Transforms;
    using IOutBitStream = Coherence.Brook.IOutBitStream;
    using global::Coherence.Generated.FirstProject;
    using Coherence.Replication.Unity;

    public class SerializeCreateEntityRequest
    {
        private MessageSerializers messageSerializers;

        public SerializeCreateEntityRequest(UnityMapper mapper)
        {
            messageSerializers = new MessageSerializers(mapper);
        }
        
        public void SerializeComponentsInMessageFormat(EntityManager entityManager,
            Entity entity, uint[] foundComponentTypes, IOutBitStream bitStream, ILog log)
        {
            var protocolOutStream = new FieldStream.Serialize.Streams.OutBitStream(bitStream, log);

            foreach (var coherenceComponentType in foundComponentTypes)
            {
				ComponentTypeIdSerializer.Serialize(coherenceComponentType, bitStream);

				switch (coherenceComponentType)
                {
					
                    case TypeIds.InternalWorldPosition:
					{
						var data = entityManager.GetComponentData<Translation>(entity);
						messageSerializers.WorldPosition(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalWorldOrientation:
					{
						var data = entityManager.GetComponentData<Rotation>(entity);
						messageSerializers.WorldOrientation(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalLocalUser:
					{
						var data = entityManager.GetComponentData<LocalUser>(entity);
						messageSerializers.LocalUser(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalWorldPositionQuery:
					{
						var data = entityManager.GetComponentData<WorldPositionQuery>(entity);
						messageSerializers.WorldPositionQuery(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalSessionBased:
					{
						var data = entityManager.GetComponentData<SessionBased>(entity);
						messageSerializers.SessionBased(protocolOutStream, data);
						break;
					}
					
                    case TypeIds.InternalPlayer:
					{
						var data = entityManager.GetComponentData<Player>(entity);
						messageSerializers.Player(protocolOutStream, data);
						break;
					}
					

                    default:
                    {
                        log.Warning($"Unknown component", "component", coherenceComponentType);
                        break;
                    }
                }
            }
        }
    }
}

// ------------------ end of SerializeCreateEntity.cs -----------------
#endregion



#region DeserializeComponentUpdate
// -----------------------------------
//  DeserializeComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Coherence.Brook;
    using Coherence.Log;
	using Unity.Entities;
	using Unity.Transforms;
    using DeltaEcs;
    using global::Coherence.Generated.FirstProject;
    using Coherence.SimulationFrame;
    using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class DeserializeComponentUpdateGenerated
    {
        private UnityReaders unityReaders;

        public DeserializeComponentUpdateGenerated(UnityMapper mapper)
        {
            unityReaders = new UnityReaders(mapper);
        }


        private void DeserializeWorldPosition(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Translation();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Ensure entities with interpolation also have Interpolation components and Sample components
			if (!entityManager.HasComponent<InterpolationComponent_Translation>(entity))
			{
				entityManager.AddComponent<InterpolationComponent_Translation>(entity);
				entityManager.AddComponent<Sample_Translation>(entity);
			}

			// Append buffer for components that use interpolation
			var tempComponentData = new Translation();
			unityReaders.Read(ref tempComponentData, protocolStream);
			if (justCreated) // Hack
			{
				entityManager.SetComponentData(entity, tempComponentData);
			}
			InterpolationSystem_Translation.AppendBuffer(entity, tempComponentData, entityManager.World, (ulong) simulationFrame.Frame);
    

		}

        private void DeserializeWorldOrientation(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new Rotation();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Ensure entities with interpolation also have Interpolation components and Sample components
			if (!entityManager.HasComponent<InterpolationComponent_Rotation>(entity))
			{
				entityManager.AddComponent<InterpolationComponent_Rotation>(entity);
				entityManager.AddComponent<Sample_Rotation>(entity);
			}

			// Append buffer for components that use interpolation
			var tempComponentData = new Rotation();
			unityReaders.Read(ref tempComponentData, protocolStream);
			if (justCreated) // Hack
			{
				entityManager.SetComponentData(entity, tempComponentData);
			}
			InterpolationSystem_Rotation.AppendBuffer(entity, tempComponentData, entityManager.World, (ulong) simulationFrame.Frame);
    

		}

        private void DeserializeLocalUser(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new LocalUser();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<LocalUser>(entity);
			unityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);
    

		}

        private void DeserializeWorldPositionQuery(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

            // If we own the entity, don't overwrite with downstream data from server
            // TODO: Server should never send downstream to the simulating client
            if (componentOwnership)
	        {
	            // Read and discard data (the stream must always be read) 
	            var temp = new WorldPositionQuery();
				unityReaders.Read(ref temp, protocolStream);
				return;
            }
            
    
			// Overwrite components that don't use interpolation
			var componentData = entityManager.GetComponentData<WorldPositionQuery>(entity);
			unityReaders.Read(ref componentData, protocolStream);
			entityManager.SetComponentData(entity, componentData);
    

		}

        private void DeserializeSessionBased(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

			// No need to read empty components, just ensure that it's there
            if (!entityManager.HasComponent<SessionBased>(entity))
		    {
				entityManager.AddComponent<SessionBased>(entity);
			}

		}

        private void DeserializePlayer(EntityManager entityManager, Entity entity, bool componentOwnership, AbsoluteSimulationFrame simulationFrame, Coherence.Replication.Protocol.Definition.IInBitStream protocolStream, bool justCreated, IInBitStream bitStream)
        {

			// No need to read empty components, just ensure that it's there
            if (!entityManager.HasComponent<Player>(entity))
		    {
				entityManager.AddComponent<Player>(entity);
			}

		}

        

        public void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, false, log);
		}

        public void ReadComponentDataUpdateEx(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, bool justCreated, ILog log)
        {
            var componentOwnership = Deserializator.ReadComponentOwnership(bitStream, log); // Read bit from stream...
            componentOwnership = entityManager.HasComponent<Simulated>(entity); // Then overwrite it with entity ownership.
            var inProtocolStream = new Coherence.FieldStream.Deserialize.Streams.InBitStream(bitStream, log);
            switch (componentType)
            {
				
			case TypeIds.InternalWorldPosition:
				DeserializeWorldPosition(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalWorldOrientation:
				DeserializeWorldOrientation(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalLocalUser:
				DeserializeLocalUser(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalWorldPositionQuery:
				DeserializeWorldPositionQuery(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalSessionBased:
				DeserializeSessionBased(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				
			case TypeIds.InternalPlayer:
				DeserializePlayer(entityManager, entity, componentOwnership, simulationFrame, inProtocolStream, justCreated, bitStream);
				break;
				

			default:
				log.Warning("couldn't find component", "componentType", componentType);
				break;
			}
		}
		
        public void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
#region Commands

            {
                var hasBuffer = entityManager.HasComponent<Doit>(entity);
                if (!hasBuffer)
                {
                    entityManager.AddBuffer<Doit>(entity);
                }
    
                var hasRequestBuffer = entityManager.HasComponent<DoitRequest>(entity);
                if (!hasRequestBuffer)
                {
                    entityManager.AddBuffer<DoitRequest>(entity);
                }
            }

#endregion

            switch (componentType)
            {

				case TypeIds.InternalWorldPosition:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Translation>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPosition_Sync>(entity) && entityManager.GetComponentData<WorldPosition_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Translation());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalWorldOrientation:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Rotation>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldOrientation_Sync>(entity) && entityManager.GetComponentData<WorldOrientation_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Rotation());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalLocalUser:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<LocalUser_Sync>(entity) && entityManager.GetComponentData<LocalUser_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new LocalUser());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalWorldPositionQuery:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<WorldPositionQuery_Sync>(entity) && entityManager.GetComponentData<WorldPositionQuery_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new WorldPositionQuery());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalSessionBased:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<SessionBased>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<SessionBased_Sync>(entity) && entityManager.GetComponentData<SessionBased_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new SessionBased());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

				case TypeIds.InternalPlayer:
                {
                    var justCreated = false;
                    var hasComponentData = entityManager.HasComponent<Player>(entity);
                    var componentHasBeenRemoved = entityManager.HasComponent<Player_Sync>(entity) && entityManager.GetComponentData<Player_Sync>(entity).deletedAtTime > 0;
                    if (!hasComponentData && !componentHasBeenRemoved)
                    {
                        entityManager.AddComponentData(entity, new Player());
                        justCreated = true;
                    }

                    ReadComponentDataUpdateEx(entityManager, entity, componentType, simulationFrame, bitStream, justCreated, log);
                    break;
				}

                default:
				{
                    log.Warning("can not create component type");
                    break;
				}
            }
        }		
    }

    public class ComponentDeserializeWrapper : ISchemaSpecificComponentDeserialize
    {
        private DeserializeComponentUpdateGenerated deserializeComponentUpdateGenerated;

        public ComponentDeserializeWrapper(UnityMapper mapper)
        {
            deserializeComponentUpdateGenerated = new DeserializeComponentUpdateGenerated(mapper);
        }

        public void CreateIfNeededAndReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            deserializeComponentUpdateGenerated.CreateIfNeededAndReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }

        public void ReadComponentDataUpdate(EntityManager entityManager, Entity entity, uint componentType, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream, ILog log)
        {
            deserializeComponentUpdateGenerated.ReadComponentDataUpdate(entityManager, entity, componentType, simulationFrame, bitStream, log);
        }
    }

}

// ------------------ end of DeserializeComponentUpdate.cs -----------------
#endregion



#region DeserializeAndSkipComponentUpdate
// -----------------------------------
//  DeserializeAndSkipComponentUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Coherence.Log;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;
    using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class DeserializeComponentUpdateSkipGenerated
    {
        private UnityReaders unityReaders;

        public DeserializeComponentUpdateSkipGenerated(UnityMapper mapper)
        {
            unityReaders = new UnityReaders(mapper);
        }

		
		private void DeserializeWorldPosition(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Translation();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeWorldOrientation(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Rotation();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeLocalUser(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new LocalUser();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeWorldPositionQuery(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new WorldPositionQuery();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializeSessionBased(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new SessionBased();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
		private void DeserializePlayer(Coherence.Replication.Protocol.Definition.IInBitStream protocolStream)
		{
            var ignored = new Player();
            unityReaders.Read(ref ignored, protocolStream);
		}
		
 
		public void SkipComponentDataUpdate(uint componentType, Coherence.Replication.Protocol.Definition.IInBitStream inProtocolStream, ILog log)
        {
			switch (componentType)
            {

                case TypeIds.InternalWorldPosition:
					DeserializeWorldPosition(inProtocolStream);
                    break;

                case TypeIds.InternalWorldOrientation:
					DeserializeWorldOrientation(inProtocolStream);
                    break;

                case TypeIds.InternalLocalUser:
					DeserializeLocalUser(inProtocolStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
					DeserializeWorldPositionQuery(inProtocolStream);
                    break;

                case TypeIds.InternalSessionBased:
					DeserializeSessionBased(inProtocolStream);
                    break;

                case TypeIds.InternalPlayer:
					DeserializePlayer(inProtocolStream);
                    break;

			}
		}
    }
    
    public class DeserializeComponentsAndSkipWrapper : ISchemaSpecificComponentDeserializerAndSkip
    {
        DeserializeComponentUpdateSkipGenerated deserializeComponentUpdateSkipGenerated;

        public DeserializeComponentsAndSkipWrapper(UnityMapper mapper)
        {
            deserializeComponentUpdateSkipGenerated = new DeserializeComponentUpdateSkipGenerated(mapper);
        }

        public void DeserializeAndSkipComponent(uint componentTypeId, Coherence.Replication.Protocol.Definition.IInBitStream protocolOutStream, ILog log)
        {
            deserializeComponentUpdateSkipGenerated.SkipComponentDataUpdate(componentTypeId, protocolOutStream, log);
        }
    }    
}

// ------------------ end of DeserializeAndSkipComponentUpdate.cs -----------------
#endregion



#region SyncReceiveSystem
// -----------------------------------
//  SyncReceiveSystem.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Coherence.SimulationFrame;
    using Protocol.Deserialize;
    using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Sdk.Unity;

    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(InitializationSystemGroup))]
    [AlwaysUpdateSystem]
    public class SyncReceiveSystem : SystemBase
    {
        private Receiver receiver;
        CoherenceSimulationSystemGroup simGroup;
        private bool hasInitialTime;
        private bool isBooted;

        private void BootUp()
        {
	        simGroup = World.GetExistingSystem<CoherenceSimulationSystemGroup>();
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
            var deserializeComponents = new ComponentDeserializeWrapper(netSys.Mapper);
            var skipper = new DeserializeComponentsAndSkipWrapper(netSys.Mapper);
            var commandPerform = new PerformCommands(netSys.Mapper);
            var eventPerform = new PerformEvents(netSys.Mapper);
            var receiveUpdate = new ReceiveUpdate(deserializeComponents, skipper, netSys.Mapper, netSys.DestroyedEntities, netSys.Log);
            receiver = new Receiver(World, netSys.Mapper, netSys.Connector, receiveUpdate, commandPerform, eventPerform, netSys.SentPacketsCache, netSys.Log);
        }

        private void ChangeClockSpeed(ClockSpeedFactor factor)
        {
            const float desiredTimestep = 1f / 60f;
            const int maxSubsteps = 10;
            var timeStep = 0f;
            if (factor.FactorTimesThousand <= 1)
            {
            }
            else
            {
	            timeStep = desiredTimestep * 1000f / factor.FactorTimesThousand;
            }

            simGroup.SetTimeStep(true, timeStep, maxSubsteps);
        }

        protected override void OnUpdate()
        {
	        if (!isBooted)
	        {
		        isBooted = true;
		        BootUp();
	        }

            // Respond to network disconnect events
	        Entities.ForEach((in DisconnectedEvent connected) =>
	        {
		        // Destroy all networked entities 
		        World.GetOrCreateSystem<NetworkSystem>().Mapper.ClearAndDestroyEntities();
		        
		        // Clear the incoming packet repository
		        receiver.ResetPacketRepository();
	        }).WithStructuralChanges().WithoutBurst().Run();

            var simulationFrame = new AbsoluteSimulationFrame { Frame = (long)simGroup.SimulationFrame };
            var adjust = receiver.OnUpdate(simulationFrame);

            if (adjust.State != SpecialCommandState.Ignore)
	        {
	            var needsToOverwriteTime = (!hasInitialTime && adjust.SimulationFrame.Frame != 0) || adjust.State == SpecialCommandState.Reset;

	            if (needsToOverwriteTime)
	            {
	                simGroup.SetSimulationFrame((ulong)adjust.SimulationFrame.Frame);
	                hasInitialTime = true;
	            }

	            ChangeClockSpeed(adjust.ClockSpeed);
            }
        }
    }
}

// ------------------ end of SyncReceiveSystem.cs -----------------
#endregion



#region SyncComponent
// -----------------------------------
//  SyncComponent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using Unity.Entities;
    using Unity.Transforms;
    using global::Coherence.Generated.FirstProject;


    public struct WorldPosition_Sync : IComponentData
    {
        public Translation lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct WorldOrientation_Sync : IComponentData
    {
        public Rotation lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct LocalUser_Sync : IComponentData
    {
        public LocalUser lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct WorldPositionQuery_Sync : IComponentData
    {
        public WorldPositionQuery lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct SessionBased_Sync : IComponentData
    {
        public SessionBased lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


    public struct Player_Sync : IComponentData
    {
        public Player lastSentData;
        public uint resendMask;
        public uint howImportantAreYou;
        public uint accumulatedPriority;
        public long deletedAtTime;
        public bool hasBeenSerialized;
        public bool deleteHasBeenSerialized;
        public bool hasReceivedConstructor;
    }


}


// ------------------ end of SyncComponent.cs -----------------
#endregion



#region SerializeComponentUpdate
// -----------------------------------
//  SerializeComponentUpdate.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using System;
	using Unity.Entities;
	using Unity.Transforms;
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Protocol.Definition;
	using Replication.Client.Unity.Ecs;
    using Coherence.Replication.Unity;

    public class SerializeComponentUpdatesGenerated
    {
         private UnityWriters unityWriters;

         public SerializeComponentUpdatesGenerated(UnityMapper mapper)
         {
             unityWriters = new UnityWriters(mapper);
         }


        private void SerializeWorldPosition(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Translation>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPosition_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeWorldOrientation(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<Rotation>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldOrientation_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeLocalUser(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<LocalUser>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<LocalUser_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeWorldPositionQuery(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Write component changes to output stream
            var componentData = EntityManager.GetComponentData<WorldPositionQuery>(entity);
            unityWriters.Write(componentData, mask, protocolOutStream);

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.lastSentData = componentData;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializeSessionBased(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<SessionBased_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

        private void SerializePlayer(EntityManager EntityManager, Entity entity, uint mask, IOutBitStream protocolOutStream)
        {

            // Reset accumulated priority so the same component is not sent again next frame
            var syncData = EntityManager.GetComponentData<Player_Sync>(entity);

            syncData.accumulatedPriority = 0;

            syncData.hasBeenSerialized = true;
            syncData.resendMask &= ~mask;	// Clear serialized fields from resend mask
            EntityManager.SetComponentData(entity, syncData);
        }
        

    
        public void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint componentType, uint fieldMask, IOutBitStream protocolOutStream)
        {
            switch (componentType)
            {

                case TypeIds.InternalWorldPosition:
                    SerializeWorldPosition(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalWorldOrientation:
                    SerializeWorldOrientation(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalLocalUser:
                    SerializeLocalUser(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalWorldPositionQuery:
                    SerializeWorldPositionQuery(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalSessionBased:
                    SerializeSessionBased(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                case TypeIds.InternalPlayer:
                    SerializePlayer(entityManager, unityEntity, fieldMask, protocolOutStream);
                    break;

                default:
                    throw new Exception($"unknown componentType {componentType}");
            }
        }
    
        
        public void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
        {
            switch (componentTypeId)
            {

                case TypeIds.InternalWorldPosition:
                {
                    var syncData = entityManager.GetComponentData<WorldPosition_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalWorldOrientation:
                {
                    var syncData = entityManager.GetComponentData<WorldOrientation_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalLocalUser:
                {
                    var syncData = entityManager.GetComponentData<LocalUser_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalWorldPositionQuery:
                {
                    var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalSessionBased:
                {
                    var syncData = entityManager.GetComponentData<SessionBased_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }

                case TypeIds.InternalPlayer:
                {
                    var syncData = entityManager.GetComponentData<Player_Sync>(unityEntity);
                    syncData.deleteHasBeenSerialized = true;
                    entityManager.SetComponentData(unityEntity, syncData);
                    break;
                }


                default:
                    throw new Exception($"unknown componentType {componentTypeId}");
            }
        }
    }
    
    class SerializeComponentUpdatesWrapper : ISchemaSpecificComponentSerializer
    {
        private SerializeComponentUpdatesGenerated serializeComponentUpdatesGenerated;

        public SerializeComponentUpdatesWrapper(UnityMapper mapper)
        {
            serializeComponentUpdatesGenerated = new SerializeComponentUpdatesGenerated(mapper);
        }

    	public void SerializeComponent(EntityManager entityManager, Entity unityEntity, uint ComponentTypeId, uint fieldMask, IOutBitStream protocolOutStream)
    	{
    		serializeComponentUpdatesGenerated.SerializeComponent(entityManager, unityEntity, ComponentTypeId, fieldMask, protocolOutStream);
    	}
    	
    	public void UpdateDestructState(EntityManager entityManager, Entity unityEntity, uint componentTypeId)
    	{
            serializeComponentUpdatesGenerated.UpdateDestructState(entityManager, unityEntity, componentTypeId);
        }
    }

}


// ------------------ end of SerializeComponentUpdate.cs -----------------
#endregion



#region ComponentMaskDeserializers
// -----------------------------------
//  ComponentMaskDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Unity.Transforms;
	using Coherence.Replication.Unity;
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;


public class UnityReaders
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public UnityReaders(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }
	
	public uint Read(ref Translation data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;


		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
			     data.Value = coherenceToUnityConverters.ToUnityfloat3(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	public uint Read(ref Rotation data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;


		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadUnitRotation();
			     data.Value = coherenceToUnityConverters.ToUnityquaternion(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	public uint Read(ref LocalUser data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;


		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadIntegerRange(15, -9999);
			       data.localIndex = coherenceField;
			propertyMask |= 0b00000000000000000000000000000001;
		}
       
		return propertyMask;
	}

	
	public uint Read(ref WorldPositionQuery data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;


		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadVector3f(24, 2400);
			     data.position = coherenceToUnityConverters.ToUnityfloat3(coherenceField);
			propertyMask |= 0b00000000000000000000000000000001;
		}

		if (bitstream.ReadMask()) 
		{
			var coherenceField = bitstream.ReadFixedPoint(24, 40000);
			     data.radius = coherenceToUnityConverters.ToUnityfloat(coherenceField);
			propertyMask |= 0b00000000000000000000000000000010;
		}
       
		return propertyMask;
	}

	
	public uint Read(ref SessionBased data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

       
		return propertyMask;
	}

	
	public uint Read(ref Player data, IInBitStream bitstream)
	{
		var propertyMask = (uint)0;

       
		return propertyMask;
	}

	
}

}

// ------------------ end of ComponentMaskDeserializers.cs -----------------
#endregion



#region ComponentMaskSerializers
// -----------------------------------
//  ComponentMaskSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Replication.Unity;
	using Unity.Transforms;


	public class UnityWriters
	{
        private CoherenceToUnityConverters coherenceToUnityConverters;

        public UnityWriters(UnityMapper mapper)
        {
            coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
        }

		
		
		public void Write(in Translation data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = coherenceToUnityConverters.FromUnityfloat3(data.Value);
					bitstream.WriteVector3f(v, 24, 2400);
				
			}
			propertyMask >>= 1;
	
	     }

		
		
		public void Write(in Rotation data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = coherenceToUnityConverters.FromUnityquaternion(data.Value);
					bitstream.WriteUnitRotation(v);
				
			}
			propertyMask >>= 1;
	
	     }

		
		
		public void Write(in LocalUser data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
				
			}
			propertyMask >>= 1;
	
	     }

		
		
		public void Write(in WorldPositionQuery data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = coherenceToUnityConverters.FromUnityfloat3(data.position);
					bitstream.WriteVector3f(v, 24, 2400);
				
			}
			propertyMask >>= 1;
	
			if (bitstream.WriteMask((propertyMask & 0x01) != 0))
			{
				
					var v = coherenceToUnityConverters.FromUnityfloat(data.radius);
					bitstream.WriteFixedPoint(v, 24, 40000);
				
			}
			propertyMask >>= 1;
	
	     }

		
		
		public void Write(in SessionBased data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
	     }

		
		
		public void Write(in Player data, uint propertyMask, Coherence.Replication.Protocol.Definition.IOutBitStream bitstream)
		{
	
	     }

		
	}
}

// ------------------ end of ComponentMaskSerializers.cs -----------------
#endregion



#region MessageSerializers
// -----------------------------------
//  MessageSerializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;
	using Replication.Unity;


public class MessageSerializers
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public MessageSerializers(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }


	public void WorldPosition(IOutBitStream bitstream, Translation data)
	{

			
				var converted_value = coherenceToUnityConverters.FromUnityfloat3(data.Value);
				bitstream.WriteVector3f(converted_value, 24, 2400);
			

	}

	public void WorldOrientation(IOutBitStream bitstream, Rotation data)
	{

			
				var converted_value = coherenceToUnityConverters.FromUnityquaternion(data.Value);
				bitstream.WriteUnitRotation(converted_value);
			

	}

	public void LocalUser(IOutBitStream bitstream, LocalUser data)
	{

			
				bitstream.WriteIntegerRange(data.localIndex, 15, -9999);
			

	}

	public void WorldPositionQuery(IOutBitStream bitstream, WorldPositionQuery data)
	{

			
				var converted_position = coherenceToUnityConverters.FromUnityfloat3(data.position);
				bitstream.WriteVector3f(converted_position, 24, 2400);
			

			
				var converted_radius = coherenceToUnityConverters.FromUnityfloat(data.radius);
				bitstream.WriteFixedPoint(converted_radius, 24, 40000);
			

	}

	public void SessionBased(IOutBitStream bitstream, SessionBased data)
	{

	}

	public void Player(IOutBitStream bitstream, Player data)
	{

	}

	public void Doit(IOutBitStream bitstream, Doit data)
	{

			
				bitstream.WriteIntegerRange(data.number, 15, -9999);
			

			
				var converted_fnum = coherenceToUnityConverters.FromUnityfloat(data.fnum);
				bitstream.WriteFixedPoint(converted_fnum, 24, 40000);
			

			
				bitstream.WriteBool(data.b);
			

			
				var converted_v3 = coherenceToUnityConverters.FromUnityfloat3(data.v3);
				bitstream.WriteVector3f(converted_v3, 24, 2400);
			

			
				var converted_v2 = coherenceToUnityConverters.FromUnityfloat2(data.v2);
				bitstream.WriteVector2f(converted_v2, 24, 2400);
			

			
				var converted_rot = coherenceToUnityConverters.FromUnityquaternion(data.rot);
				bitstream.WriteUnitRotation(converted_rot);
			

			
				var converted_e = coherenceToUnityConverters.FromUnityEntity(data.e);
				bitstream.WriteEntity(converted_e);
			

			
				var converted_text = coherenceToUnityConverters.FromUnityFixedString64(data.text);
				bitstream.WriteShortString(converted_text);
			

	}


/// ------------------------ Requests --------------------------

	public void DoitRequest(IOutBitStream bitstream, DoitRequest data)
	{

			
				bitstream.WriteIntegerRange(data.number, 15, -9999);
			

			
				var converted_fnum = coherenceToUnityConverters.FromUnityfloat(data.fnum);
				bitstream.WriteFixedPoint(converted_fnum, 24, 40000);
			

			
				bitstream.WriteBool(data.b);
			

			
				var converted_v3 = coherenceToUnityConverters.FromUnityfloat3(data.v3);
				bitstream.WriteVector3f(converted_v3, 24, 2400);
			

			
				var converted_v2 = coherenceToUnityConverters.FromUnityfloat2(data.v2);
				bitstream.WriteVector2f(converted_v2, 24, 2400);
			

			
				var converted_rot = coherenceToUnityConverters.FromUnityquaternion(data.rot);
				bitstream.WriteUnitRotation(converted_rot);
			

			
				var converted_e = coherenceToUnityConverters.FromUnityEntity(data.e);
				bitstream.WriteEntity(converted_e);
			

			
				var converted_text = coherenceToUnityConverters.FromUnityFixedString64(data.text);
				bitstream.WriteShortString(converted_text);
			

	}



}

}

// ------------------ end of MessageSerializers.cs -----------------
#endregion



#region MessageDeserializers
// -----------------------------------
//  MessageDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Replication.Protocol.Definition;
	using global::Coherence.Generated.FirstProject;
	using Unity.Transforms;	
	using Replication.Unity;


public class MessageDeserializers
{
    private CoherenceToUnityConverters coherenceToUnityConverters;

    public MessageDeserializers(UnityMapper mapper)
    {
        coherenceToUnityConverters = new CoherenceToUnityConverters(mapper);
    }


	public void Translation(IInBitStream bitstream, ref Translation data)
	{

			
				var value = bitstream.ReadVector3f(24, 2400);
				data.Value = coherenceToUnityConverters.ToUnityfloat3(value);
			
     
	}

	public void Rotation(IInBitStream bitstream, ref Rotation data)
	{

			
				var value = bitstream.ReadUnitRotation();
				data.Value = coherenceToUnityConverters.ToUnityquaternion(value);
			
     
	}

	public void LocalUser(IInBitStream bitstream, ref LocalUser data)
	{

			
				data.localIndex =  bitstream.ReadIntegerRange(15, -9999);
			
     
	}

	public void WorldPositionQuery(IInBitStream bitstream, ref WorldPositionQuery data)
	{

			
				var position = bitstream.ReadVector3f(24, 2400);
				data.position = coherenceToUnityConverters.ToUnityfloat3(position);
			

			
				var radius = bitstream.ReadFixedPoint(24, 40000);
				data.radius = coherenceToUnityConverters.ToUnityfloat(radius);
			
     
	}

	public void SessionBased(IInBitStream bitstream, ref SessionBased data)
	{
     
	}

	public void Player(IInBitStream bitstream, ref Player data)
	{
     
	}

	public void Doit(IInBitStream bitstream, ref Doit data)
	{

			
				data.number =  bitstream.ReadIntegerRange(15, -9999);
			

			
				var fnum = bitstream.ReadFixedPoint(24, 40000);
				data.fnum = coherenceToUnityConverters.ToUnityfloat(fnum);
			

			
				data.b =  bitstream.ReadBool();
			

			
				var v3 = bitstream.ReadVector3f(24, 2400);
				data.v3 = coherenceToUnityConverters.ToUnityfloat3(v3);
			

			
				var v2 = bitstream.ReadVector2f(24, 2400);
				data.v2 = coherenceToUnityConverters.ToUnityfloat2(v2);
			

			
				var rot = bitstream.ReadUnitRotation();
				data.rot = coherenceToUnityConverters.ToUnityquaternion(rot);
			

			
				var e = bitstream.ReadEntity();
				data.e = coherenceToUnityConverters.ToUnityEntity(e);
			

			
				var text = bitstream.ReadShortString();
				data.text = coherenceToUnityConverters.ToUnityFixedString64(text);
			
     
	}


}

}

// ------------------ end of MessageDeserializers.cs -----------------
#endregion



#region CommandDeserializers
// -----------------------------------
//  CommandDeserializers.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Log;
	using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;

	public class PerformCommands : IPerformCommand
	{
        private MessageDeserializers messageDeserializers;

         public PerformCommands(UnityMapper mapper)
         {
             messageDeserializers = new MessageDeserializers(mapper);
         }

		public void PerformCommand(EntityManager mgr, Entity entity, uint commandTypeID, Coherence.Replication.Protocol.Definition.IInBitStream bitStream, ILog log)
		{

			switch (commandTypeID)
			{

				case TypeIds.InternalDoit:
				{
					var hasRequestBuffer = mgr.HasComponent<Doit>(entity);
					if (!hasRequestBuffer)
					{
						mgr.AddBuffer<Doit>(entity);
					}
					var buffer = mgr.GetBuffer<Doit>(entity);
					var data = new Doit();
					messageDeserializers.Doit(bitStream, ref data);
					buffer.Add(data);
					break;
				}

			}

		}
	}
}


// ------------------ end of CommandDeserializers.cs -----------------
#endregion



#region RuntimeSystem
// -----------------------------------
//  RuntimeSystem.cs
// -----------------------------------
			
namespace Coherence.Sdk.Unity
{
	using Coherence.Generated.Internal.FirstProject;
	using global::Unity.Entities;
	using global::Unity.Transforms;
	using Coherence.Log;
	using Replication.Client.Unity.Ecs;
	using global::Coherence.Generated.FirstProject;

	[UpdateInGroup(typeof(SimulationSystemGroup))]
	public class CoherenceRuntimeSystem : ComponentSystem
	{
		protected override void OnCreate()
		{
			#region Register all known component types and their enums
			           GlobalLookups.Register<Translation>(TypeEnums.InternalWorldPosition);
           GlobalLookups.Register<Rotation>(TypeEnums.InternalWorldOrientation);
           GlobalLookups.Register<LocalUser>(TypeEnums.InternalLocalUser);
           GlobalLookups.Register<WorldPositionQuery>(TypeEnums.InternalWorldPositionQuery);
           GlobalLookups.Register<SessionBased>(TypeEnums.InternalSessionBased);
           GlobalLookups.Register<Player>(TypeEnums.InternalPlayer);

			#endregion

			#region Register all known component types and their component type id
			           GlobalTypeIdLookups.Register<Translation>(TypeIds.InternalWorldPosition);
           GlobalTypeIdLookups.Register<Rotation>(TypeIds.InternalWorldOrientation);
           GlobalTypeIdLookups.Register<LocalUser>(TypeIds.InternalLocalUser);
           GlobalTypeIdLookups.Register<WorldPositionQuery>(TypeIds.InternalWorldPositionQuery);
           GlobalTypeIdLookups.Register<SessionBased>(TypeIds.InternalSessionBased);
           GlobalTypeIdLookups.Register<Player>(TypeIds.InternalPlayer);

			#endregion

			base.OnCreate();
		}

		protected override void OnUpdate()
		{
		}
	}
}

// ------------------ end of RuntimeSystem.cs -----------------
#endregion



#region DetectEntityCreateAndDestroy
// -----------------------------------
//  DetectEntityCreateAndDestroy.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
    using Replication.Client.Unity.Ecs;
	using Unity.Collections;
    using Unity.Entities;
    using Replication.Unity;
    using Unity.Transforms;
    using UnityEngine;    
    
    // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(SyncSendSystem))]
    public class DetectEntityCreateSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            if (World.GetExistingSystem<SyncSendSystem>().Sender == null)
            {
                Debug.LogWarning("No sender");
                return;
            }
            var mapper = World.GetExistingSystem<SyncSendSystem>().Sender.Mapper;
            
            Entities.WithNone<Mapped>().ForEach((Entity entity, int entityInQueryIndex, in Simulated simulate) =>
            {
                var id = mapper.NextEntityId;
                mapper.Add(id, entity);
                EntityManager.AddComponent<Mapped>(entity);
            }).WithStructuralChanges().WithoutBurst().Run();

            Dependency.Complete();
       }
    }
} // namespace
        


// ------------------ end of DetectEntityCreateAndDestroy.cs -----------------
#endregion



#region DetectCommandSent
// -----------------------------------
//  DetectCommandSent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using UnityEngine;
    using Unity.Entities;
    using global::Coherence.Generated.FirstProject;

    using Message;
    using Message.Serializer.Serialize;
    using Coherence.Brisk.Connect;
    using Coherence.Brook;
    using Coherence.Log;
    using Replication.Client.Unity.Ecs;
    using Replication.Unity;

   // ReSharper disable once ClassNeverInstantiated.Global
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [AlwaysUpdateSystem]
    public class DetectCommandsSentSystem : SystemBase
    {
        private bool isBooted;
	    private Sender cachedSender;
		private MessageSerializers messageSerializers;

        void BootUp()
        {
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
			messageSerializers = new MessageSerializers(netSys.Mapper);
        }

	    protected override void OnUpdate()
	    {
	        if (!isBooted)
	        {
		        BootUp();
		        isBooted = true;
	        }

		    if (cachedSender == null)
		    {
			    cachedSender = World.GetExistingSystem<SyncSendSystem>().Sender;
			    if (cachedSender == null)
			    {
				    return;
			    }
            }

	        var burstSender = cachedSender;
	        var mapper = cachedSender.Mapper;



#region DoitRequest
			// ------------  DoitRequest --------------
            Entities
                .ForEach((Entity entity, DynamicBuffer<DoitRequest> buffer) =>
                    {
                        if (buffer.Length == 0)
                        {
                            return;
                        }
                        var rawArray = buffer.Reinterpret<DoitRequest>();
                        
                        Debug.LogWarning($"I will send {rawArray.Length} DoitRequest commands to entity: {entity}");

                        var foundEntity = mapper.ToCoherenceEntityId(entity, out var coherenceEntityId);
                        if (!foundEntity)
                        {
	                        Debug.LogError($"send command request. Can not find entity {entity}");
	                        return;
                        }
                        
						for (var i=0; i<rawArray.Length; i++)
                        {
	                        var item = rawArray[i];
	                        var octetStream = new OctetWriter(512);
	                        var bitStream = new OutBitStream(octetStream);
	                        EntityIdSerializer.Serialize(coherenceEntityId, bitStream);
	                        var protocol = new Coherence.FieldStream.Serialize.Streams.OutBitStream(bitStream, null);

	                        // --------- Type Specific Part ---------------
	                        ComponentTypeIdSerializer.Serialize(TypeIds.InternalDoit, bitStream);
	                        messageSerializers.DoitRequest(protocol, item);
	                        // --------------------------------------------

	                        bitStream.Flush();
	                        var payload = new BitSerializedMessage(octetStream.Octets, bitStream.Tell);
	                        burstSender.MessageChannels.PushEntityCommand(payload);
                        }

                        buffer.Clear();
					}).WithoutBurst().Run();
#endregion


        }
    }

}


// ------------------ end of DetectCommandSent.cs -----------------
#endregion



#region ReceiveUpdate
// -----------------------------------
//  ReceiveUpdate.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using Coherence.Ecs;
	using Coherence.DeltaEcs;
	using Coherence.Replication.Unity;
	using Coherence.Replication.Client.Unity.Ecs;
	using global::Unity.Transforms;
	using global::Unity.Collections;
	using global::Unity.Entities;
	using Coherence.Brook;
	using Coherence.Log;
	using Coherence.SimulationFrame;
	using global::Coherence.Generated.FirstProject;

	public class ReceiveUpdate : IReceiveUpdate
	{
		private readonly ISchemaSpecificComponentDeserialize componentDeserialize;
		private readonly ILog log;
		private UnityMapper mapper;
		private readonly ISchemaSpecificComponentDeserializerAndSkip componentSkip;
		private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;

		public ReceiveUpdate(ISchemaSpecificComponentDeserialize componentDeserialize,  ISchemaSpecificComponentDeserializerAndSkip componentSkip, UnityMapper mapper, NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities, ILog log)
		{
			this.componentDeserialize = componentDeserialize;
			this.componentSkip = componentSkip;
			this.mapper = mapper;
			this.log = log;
			this.destroyedEntities = destroyedEntities;
		}

		private void DestroyComponentData(EntityManager entityManager, Entity entity, uint componentType)
		{
			switch (componentType)
			{

				case TypeIds.InternalWorldPosition:
				{
					var hasComponentData = entityManager.HasComponent<Translation>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Translation>(entity);
					}
					break;
				}

				case TypeIds.InternalWorldOrientation:
				{
					var hasComponentData = entityManager.HasComponent<Rotation>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Rotation>(entity);
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<LocalUser>(entity);
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<WorldPositionQuery>(entity);
					}
					break;
				}

				case TypeIds.InternalSessionBased:
				{
					var hasComponentData = entityManager.HasComponent<SessionBased>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<SessionBased>(entity);
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player>(entity);
					if (hasComponentData)
					{
						entityManager.RemoveComponent<Player>(entity);
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentType);
					break;
				}
			}
		}

		private void UpdateComponents(EntityManager entityManager, Entity entity, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
		{
			var componentCount = Deserializator.ReadComponentCount(bitStream, log);
			for (var i = 0; i < componentCount; i++)
			{
				var componentState = Deserializator.ReadComponentState(bitStream, log);
				var componentId = Deserializator.ReadComponentId(bitStream, log);
				switch (componentState)
				{
					case ComponentState.Construct:
						{
							var componentTypeId = Deserializator.ReadComponentTypeId(bitStream, log);

							componentDeserialize.CreateIfNeededAndReadComponentDataUpdate(entityManager,
								entity, componentTypeId, simulationFrame, bitStream, log);
						}
						break;
					case ComponentState.Update:
						{
							// TODO: lookup component ID from state.
							var updateComponentTypeId = componentId;
							componentDeserialize.ReadComponentDataUpdate(entityManager, entity,
								updateComponentTypeId, simulationFrame, bitStream, log);
						}
						break;
					case ComponentState.Destruct:
						{
							var destroyComponentTypeId = componentId;
							DestroyComponentData(entityManager, entity, destroyComponentTypeId);
						}
						break;
				}
			}
		}

		public void PerformUpdate(EntityManager entityManager, AbsoluteSimulationFrame simulationFrame, IInBitStream bitStream)
		{
			var deserializeEntity = new Deserializator();

			while (deserializeEntity.ReadEntity(bitStream, out var entityWithMeta, log))
			{
				var entity = mapper.ToUnityEntity(entityWithMeta.EntityId, false);

				// Skip locally destroyed entities
				if (destroyedEntities.ContainsKey(entity))
				{
					if (!entityWithMeta.IsDeleted)
					{
						DeserializeComponentSkip.SkipComponents(componentSkip, bitStream, log);
					}
					continue;
				}

				// Meta information concerns entity creation, destruction and ownership
				if (entityWithMeta.HasMeta)
				{
					entity = PerformEntityMetaUpdate(entityManager, entityWithMeta, entity);
				}

				// Deserialize and apply component updates
				if (entity != default)
				{
					if (entityManager.HasComponent<Simulated>(entity))
					{
						DeserializeComponentSkip.SkipComponents(componentSkip, bitStream, log);
						log.Warning($"Trying to update owned entity {entityWithMeta.EntityId}");
					}
					else
					{
						UpdateComponents(entityManager, entity, simulationFrame, bitStream);
					}
				} else if (!entityWithMeta.IsDeleted)
				{
					// An error has occurred if the entity is null unless it's because it was just deleted
					log.Warning($"Entity is missing {entityWithMeta.EntityId}");
				}
			}
		}

		private Entity PerformEntityMetaUpdate(EntityManager entityManager, Deserializator.EntityWithMeta entityWithMeta, Entity entity)
		{
			// Entities are CREATED implicitly if they do not exist
			if (entity == default || !entityManager.Exists(entity))
			{
				if (entity != default)
				{
					UnityEngine.Debug.LogWarning("entity might still be mapped: " + entity + " CID: " + entityWithMeta.EntityId);
				}
				if (mapper.IsEntityIdInUse(entityWithMeta.EntityId))
				{
					UnityEngine.Debug.LogWarning("entity index already in use: " + entityWithMeta.EntityId);
					return default;
				}
				entity = entityManager.CreateEntity();
				mapper.Add(entityWithMeta.EntityId, entity);
				entityManager.AddComponent<Mapped>(entity);
			}

			// Entities OWNERSHIP determines iff they should have Simulated
			var hasComponentData = entityManager.HasComponent<Simulated>(entity);
			if (hasComponentData && !entityWithMeta.Ownership)
			{
				entityManager.RemoveComponent<Simulated>(entity);
				entityManager.RemoveComponent<LingerSimulated>(entity);
				RemoveSyncComponents(entityManager, entity);
			}
			else if (!hasComponentData && entityWithMeta.Ownership)
			{
				entityManager.AddComponentData(entity, new Simulated());
				RemoveInterpolationComponents(entityManager, entity);
			}

			// Entities are DELETED explicitly by the IsDeleted flag
			if (entityWithMeta.IsDeleted)
			{
				if (!entityWithMeta.Ownership)
				{
					log.Debug($"Deleting entity {entityWithMeta.Ownership} {entityWithMeta.EntityId}");
					if (entity != default)
					{
						if (entityManager.Exists(entity))
						{
							mapper.Remove(entityWithMeta.EntityId); // This internally requires entity to exist...
							entityManager.RemoveComponent<LingerSimulated>(entity);
							entityManager.DestroyEntity(entity);    // ...so this must be executed afterwards ...
						}
						else
						{
							log.Warning($"Entity has already been deleted: {entityWithMeta.EntityId} : {entity}");
						}
					}
					else
					{
						log.Warning($"Attempted to delete missing entity: {entityWithMeta.EntityId}");
					}
				}
				else
				{
					log.Warning($"Attempted to delete owned entity: {entityWithMeta.EntityId}");
				}

				return default;
			}

			return entity;
		}

		public void UpdateResendMask(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, uint componentTypeId, uint fieldMask)
		{
			var entity = mapper.ToUnityEntity(entityId);

			switch (componentTypeId)
			{

				case TypeIds.InternalWorldPosition:
				{
					var hasComponentData = entityManager.HasComponent<WorldPosition_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPosition_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalWorldOrientation:
				{
					var hasComponentData = entityManager.HasComponent<WorldOrientation_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldOrientation_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalSessionBased:
				{
					var hasComponentData = entityManager.HasComponent<SessionBased_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<SessionBased_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Player_Sync>(entity);

						syncData.resendMask |= fieldMask;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						log.Warning($"Entity or component has been destroyed: {entity} ComponentTypeId: {componentTypeId}");
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentTypeId);
					break;
				}
			}
		}

		public void UpdateHasReceivedConstructor(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, uint componentTypeId)
		{
			var entity = mapper.ToUnityEntity(entityId, false);

			// The entity has been deleted since the packet was sent
			if (destroyedEntities.ContainsKey(entity))
			{
				return;
			}

			if (!entityManager.Exists(entity))
			{
				log.Warning($"Entity does not exist: {entity} ComponentTypeId: {componentTypeId}");
				return;
			}

			if (!entityManager.HasComponent<Simulated>(entity))
			{
				// Ownership may have been lost since the packet was sent
				log.Trace($"Entity is missing Simulated: {entity} ComponentTypeId: {componentTypeId}");
				return;
			}

			var sim = entityManager.GetComponentData<Simulated>(entity);
			sim.hasReceivedConstructor = true;

			switch (componentTypeId)
			{

				case TypeIds.InternalWorldPosition:
				{
					var hasComponentData = entityManager.HasComponent<WorldPosition_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPosition_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldPosition_Sync");
					}
					break;
				}

				case TypeIds.InternalWorldOrientation:
				{
					var hasComponentData = entityManager.HasComponent<WorldOrientation_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldOrientation_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldOrientation_Sync");
					}
					break;
				}

				case TypeIds.InternalLocalUser:
				{
					var hasComponentData = entityManager.HasComponent<LocalUser_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<LocalUser_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} LocalUser_Sync");
					}
					break;
				}

				case TypeIds.InternalWorldPositionQuery:
				{
					var hasComponentData = entityManager.HasComponent<WorldPositionQuery_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<WorldPositionQuery_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} WorldPositionQuery_Sync");
					}
					break;
				}

				case TypeIds.InternalSessionBased:
				{
					var hasComponentData = entityManager.HasComponent<SessionBased_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<SessionBased_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} SessionBased_Sync");
					}
					break;
				}

				case TypeIds.InternalPlayer:
				{
					var hasComponentData = entityManager.HasComponent<Player_Sync>(entity);
					if (hasComponentData)
					{
						var syncData = entityManager.GetComponentData<Player_Sync>(entity);
						syncData.hasReceivedConstructor = true;
						entityManager.SetComponentData(entity, syncData);
					} else
					{
						// Ownership may have been lost since the packet was sent
						log.Trace($"Sync component has been destroyed: {entity} Player_Sync");
					}
					break;
				}

				default:
				{
					log.Warning($"Unknown component", "component", componentTypeId);
					break;
				}
			}
		}

		public void UpdateResendDestroyed(EntityManager entityManager, Coherence.Ecs.SerializeEntityID entityId, AbsoluteSimulationFrame simulationFrame)
		{
			var entity = mapper.ToUnityEntity(entityId, false);
			if (entity == default)
			{
				log.Warning($"Destroyed entity {entityId} missing from mapper");
				return;
			}

			// Flag this entity destruction to be resent
			destroyedEntities[entity] = new DetectedEntityDeletion { Entity = entity, simulationFrame = (ulong)simulationFrame.Frame, serialized = false };
		}

		private void RemoveSyncComponents(EntityManager entityManager, Entity entity)
		{

			if (entityManager.HasComponent<WorldPosition_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldPosition_Sync>(entity);
			}

			if (entityManager.HasComponent<WorldOrientation_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldOrientation_Sync>(entity);
			}

			if (entityManager.HasComponent<LocalUser_Sync>(entity))
			{
				entityManager.RemoveComponent<LocalUser_Sync>(entity);
			}

			if (entityManager.HasComponent<WorldPositionQuery_Sync>(entity))
			{
				entityManager.RemoveComponent<WorldPositionQuery_Sync>(entity);
			}

			if (entityManager.HasComponent<SessionBased_Sync>(entity))
			{
				entityManager.RemoveComponent<SessionBased_Sync>(entity);
			}

			if (entityManager.HasComponent<Player_Sync>(entity))
			{
				entityManager.RemoveComponent<Player_Sync>(entity);
			}

		}

		private void RemoveInterpolationComponents(EntityManager entityManager, Entity entity)
		{


			if (entityManager.HasComponent<InterpolationComponent_Translation>(entity))
			{
				entityManager.RemoveComponent<InterpolationComponent_Translation>(entity);
			}
			if (entityManager.HasComponent<Sample_Translation>(entity))
			{
				entityManager.RemoveComponent<Sample_Translation>(entity);
			}



			if (entityManager.HasComponent<InterpolationComponent_Rotation>(entity))
			{
				entityManager.RemoveComponent<InterpolationComponent_Rotation>(entity);
			}
			if (entityManager.HasComponent<Sample_Rotation>(entity))
			{
				entityManager.RemoveComponent<Sample_Rotation>(entity);
			}










		}
	}
}
// ------------------ end of ReceiveUpdate.cs -----------------
#endregion



#region DynamicBufferData
// -----------------------------------
//  DynamicBufferData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	

}


// ------------------ end of DynamicBufferData.cs -----------------
#endregion



#region EntityReplacer
// -----------------------------------
//  EntityReplacer.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Entities;
	using Unity.Transforms;
	using UnityEngine;
	using Coherence.Replication.Client.Unity.Ecs;

	public class EntityReplacer {
		public static void Replace(EntityManager entityManager, Entity networkEntity, Entity newEntity)
		{
#if UNITY_EDITOR
			entityManager.SetName(newEntity, $"{networkEntity} (remote)");
#endif

			CopyComponents(entityManager, networkEntity, newEntity);

			var mapper = entityManager.World.GetExistingSystem<SyncSendSystem>().Sender.Mapper;
			if (!mapper.ToCoherenceEntityId(networkEntity, out var entityId))
			{
				Debug.LogError("Networked Entity not found in mapper: " + networkEntity); // Should not happen
			}

			mapper.Remove(entityId);
			mapper.Add(entityId, newEntity);
			entityManager.DestroyEntity(networkEntity);

			Debug.Log(string.Format("Replaced networked Entity {0} with new Entity {1}.", networkEntity, newEntity));
		}

		private static void CopyComponents(EntityManager entityManager, Entity source, Entity destination)
		{
		
            if(entityManager.HasComponent<Translation>(source))
			{
		        // Translation is built in
                var data = entityManager.GetComponentData<Translation>(source);
                entityManager.SetComponentData<Translation>(destination, data);
		
			}
		
            if(entityManager.HasComponent<Rotation>(source))
			{
		        // Rotation is built in
                var data = entityManager.GetComponentData<Rotation>(source);
                entityManager.SetComponentData<Rotation>(destination, data);
		
			}
		
            if(entityManager.HasComponent<LocalUser>(source))
			{
		        // LocalUser has fields, will copy it.			
                if(!entityManager.HasComponent<LocalUser>(destination)) {
                    entityManager.AddComponentData<LocalUser>(destination, new LocalUser());
                }
				var data = entityManager.GetComponentData<LocalUser>(source);
				entityManager.SetComponentData<LocalUser>(destination, data);
		
			}
		
            if(entityManager.HasComponent<WorldPositionQuery>(source))
			{
		        // WorldPositionQuery has fields, will copy it.			
                if(!entityManager.HasComponent<WorldPositionQuery>(destination)) {
                    entityManager.AddComponentData<WorldPositionQuery>(destination, new WorldPositionQuery());
                }
				var data = entityManager.GetComponentData<WorldPositionQuery>(source);
				entityManager.SetComponentData<WorldPositionQuery>(destination, data);
		
			}
		
            if(entityManager.HasComponent<SessionBased>(source))
			{
		        // SessionBased has no fields, will just add it.
		        entityManager.AddComponentData<SessionBased>(destination, new SessionBased());
		
			}
		
            if(entityManager.HasComponent<Player>(source))
			{
		        // Player has no fields, will just add it.
		        entityManager.AddComponentData<Player>(destination, new Player());
		
			}
		

        // Command buffers
        
            if (entityManager.HasComponent<Doit>(source) &&
                !entityManager.HasComponent<Doit>(destination)) {
                entityManager.AddBuffer<Doit>(destination);
            }
            if (entityManager.HasComponent<DoitRequest>(source) &&
                !entityManager.HasComponent<DoitRequest>(destination)) {
                entityManager.AddBuffer<DoitRequest>(destination);
            }
        

		}
	}
}


// ------------------ end of EntityReplacer.cs -----------------
#endregion



#region DetectAddedComponent
// -----------------------------------
//  DetectAddedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Client.Unity.Ecs;
	using Unity.Entities;
	using Unity.Transforms;

	[UpdateInGroup(typeof(PresentationSystemGroup))]
	[UpdateBefore(typeof(DetectRemovedComponentsSystem))]
    public class DetectAddedComponentsSystem : SystemBase
    {
        protected override void OnUpdate()
        {

            Entities.WithAll<Translation, Simulated>().WithNone<WorldPosition_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldPosition_Sync 
				{
					howImportantAreYou = 1000
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<Rotation, Simulated>().WithNone<WorldOrientation_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldOrientation_Sync 
				{
					howImportantAreYou = 1000
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.LocalUser, Simulated>().WithNone<LocalUser_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new LocalUser_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.WorldPositionQuery, Simulated>().WithNone<WorldPositionQuery_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new WorldPositionQuery_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.SessionBased, Simulated>().WithNone<SessionBased_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new SessionBased_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

            Entities.WithAll<global::Coherence.Generated.FirstProject.Player, Simulated>().WithNone<Player_Sync>().ForEach((Entity entity) =>
			{

				EntityManager.AddComponentData(entity, new Player_Sync 
				{
					howImportantAreYou = 600
				});
			}).WithStructuralChanges().Run();

			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectAddedComponent.cs -----------------
#endregion



#region DetectChangedComponent
// -----------------------------------
//  DetectChangedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;
	using Unity.Entities;
	using Unity.Transforms;

	[UpdateInGroup(typeof(PresentationSystemGroup))]
	[UpdateBefore(typeof(SyncSendSystem))]
    public class DetectChangedComponentsSystem : SystemBase
    {
	    protected override void OnUpdate()
	    {
		    var componentChanges = World.GetExistingSystem<SyncSendSystem>().ComponentChanges;
		    var localComponentChanges = componentChanges.AsParallelWriter();


			Entities.ForEach((Entity entity, ref WorldPosition_Sync sync, in Translation data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.Value.Equals(sync.lastSentData.Value) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPosition,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref WorldOrientation_Sync sync, in Rotation data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.Value.Equals(sync.lastSentData.Value) ) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldOrientation,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref LocalUser_Sync sync, in global::Coherence.Generated.FirstProject.LocalUser data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (data.localIndex != sync.lastSentData.localIndex) mask |= 0b00000000000000000000000000000001;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalLocalUser,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in global::Coherence.Generated.FirstProject.WorldPositionQuery data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


                if (!data.position.Equals(sync.lastSentData.position) ) mask |= 0b00000000000000000000000000000001;



                if (data.radius != sync.lastSentData.radius) mask |= 0b00000000000000000000000000000010;



				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalWorldPositionQuery,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref SessionBased_Sync sync, in global::Coherence.Generated.FirstProject.SessionBased data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalSessionBased,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

			Entities.ForEach((Entity entity, ref Player_Sync sync, in global::Coherence.Generated.FirstProject.Player data, in Simulated simulate) =>
			{
				uint mask = 0;
				if (!sync.hasBeenSerialized) 
				{ 
					mask = 0xffffffff;
				}


				if (mask != 0 || sync.resendMask != 0)
				{
					sync.accumulatedPriority += sync.howImportantAreYou;
					var componentChange = new ComponentChange
					{
						entity = entity,
						componentType = TypeIds.InternalPlayer,
						mask = mask,
						resendMask = sync.resendMask,
						entityHasReceivedConstructor = simulate.hasReceivedConstructor,
                        componentHasReceivedConstructor = sync.hasReceivedConstructor,
					};
					
					localComponentChanges.Add(sync.accumulatedPriority, componentChange);
				}
			}).ScheduleParallel();

		
			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectChangedComponent.cs -----------------
#endregion



#region DetectRemovedComponent
// -----------------------------------
//  DetectRemovedComponent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence;
	using Coherence.Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;
	using Unity.Entities;
	using Unity.Transforms;

    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(DetectChangedComponentsSystem))]
    public class DetectRemovedComponentsSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            var simulationFrame = World.GetOrCreateSystem<CoherenceSimulationSystemGroup>().SimulationFrame;
			var componentChanges = World.GetExistingSystem<SyncSendSystem>().ComponentChanges;
			var localComponentChanges = componentChanges.AsParallelWriter();
			

			Entities.WithNone<Translation>().ForEach((Entity entity, ref WorldPosition_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPosition,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<Rotation>().ForEach((Entity entity, ref WorldOrientation_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldOrientation,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.LocalUser>().ForEach((Entity entity, ref LocalUser_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalLocalUser,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.WorldPositionQuery>().ForEach((Entity entity, ref WorldPositionQuery_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalWorldPositionQuery,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.SessionBased>().ForEach((Entity entity, ref SessionBased_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalSessionBased,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();

			Entities.WithNone<global::Coherence.Generated.FirstProject.Player>().ForEach((Entity entity, ref Player_Sync sync, in Simulated sim) =>
            {
                if (sync.deleteHasBeenSerialized)
                {
                    return;
                }
                
                if (sync.deletedAtTime == default)
                {
                    sync.deletedAtTime = (long)simulationFrame;
                }

                localComponentChanges.Add(sync.accumulatedPriority, new ComponentChange
                {
                    entity = entity,
                    componentType = TypeIds.InternalPlayer,
                    mask = 0,
                    resendMask = 0,
                });
            }).ScheduleParallel();


			Dependency.Complete();
        }
    }
}
// ------------------ end of DetectRemovedComponent.cs -----------------
#endregion



#region DetectDeletedEntity
// -----------------------------------
//  DetectDeletedEntity.cs
// -----------------------------------
			
namespace Coherence.Replication.Client.Unity.Ecs
{
	using Coherence.Replication.Unity;
	using global::Unity.Collections;
	using global::Unity.Entities;
	
	[AlwaysUpdateSystem]
	[UpdateInGroup(typeof(PresentationSystemGroup))]
	public class DetectDeletedEntitiesSystem : SystemBase
	{
		private NativeHashMap<Entity, DetectedEntityDeletion> destroyedEntities;
		private bool booted;
		
		private void Boot()
		{
			destroyedEntities = World.GetExistingSystem<NetworkSystem>().DestroyedEntities;
			booted = false;
		}
		
		protected override void OnUpdate()
		{
			if (!booted)
			{
				Boot();
			}
			
			var simulationFrame = World.GetExistingSystem<CoherenceSimulationSystemGroup>().SimulationFrame;
			
			// Ensure all simulated entities have their system state component in order to track entity destruction
			Entities.WithNone<LingerSimulated>().ForEach((Entity entity, int entityInQueryIndex, in Simulated simulate) =>
			{
				EntityManager.AddComponentData(entity, new LingerSimulated());
			}).WithStructuralChanges().WithoutBurst().Run();
			
			// Keep track of locally destroyed entities so that SyncReceiveSystem does not revive them
			var commandBuffer = World.GetExistingSystem<EndSimulationEntityCommandBufferSystem>().CreateCommandBuffer();
			Entities.WithNone<Simulated>().ForEach((Entity entity, int entityInQueryIndex, in LingerSimulated sync) =>
			{
				destroyedEntities.TryAdd(entity, new DetectedEntityDeletion { Entity = entity, simulationFrame = simulationFrame, serialized = false });
				commandBuffer.RemoveComponent<LingerSimulated>(entity);
			}).WithoutBurst().Run();
			
			// Clear entities that were locally destroyed over 10s ago, to prevent hashmap from overflowing  
			var kv = destroyedEntities.GetKeyValueArrays(Allocator.TempJob);
			for (var i = 0; i < kv.Values.Length; i++)
			{
				if (simulationFrame > kv.Values[i].simulationFrame + 60 * 10)
				{
					destroyedEntities.Remove(kv.Keys[i]);
				}
			}
			kv.Dispose();
		}
	}
}

// ------------------ end of DetectDeletedEntity.cs -----------------
#endregion



#region InjectSender
// -----------------------------------
//  InjectSender.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
    using Coherence.Replication.Client.Unity.Ecs;
    using Unity.Entities;

    [AlwaysUpdateSystem]
    [UpdateInGroup(typeof(PresentationSystemGroup))]
    [UpdateBefore(typeof(DetectDeletedEntitiesSystem))]
    public class InjectSenderSystem : SystemBase
    {
        protected override void OnUpdate()
        {
            if (World.GetExistingSystem<SyncSendSystem>().Sender != null)
            {
                return;
            }
            
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
            var wrapper = new SerializeComponentUpdatesWrapper(netSys.Mapper);
            var sender = new Sender(World, netSys.Connector, netSys.Mapper, wrapper, netSys.SentPacketsCache, netSys.Log);
            World.GetExistingSystem<SyncSendSystem>().Sender = sender;
        }
    }
}
// ------------------ end of InjectSender.cs -----------------
#endregion



#region EventData
// -----------------------------------
//  EventData.cs
// -----------------------------------
			
namespace Coherence.Generated.FirstProject
{
	using Unity.Collections;
	using Unity.Entities;
	using Unity.Mathematics;
	using Unity.Transforms;

	

}


// ------------------ end of EventData.cs -----------------
#endregion



#region SendEvent
// -----------------------------------
//  SendEvent.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
    using UnityEngine;
    using Unity.Entities;
    using global::Coherence.Generated.FirstProject;

    // TODO: Remove some of these imports
    using Message;
    using Message.Serializer.Serialize;
    using Coherence.Brisk.Connect;
    using Coherence.Brook;
    using Coherence.Log;
    using Replication.Client.Unity.Ecs;
    using Replication.Unity;

    [UpdateInGroup(typeof(CoherenceSimulationSystemGroup))]
    [AlwaysUpdateSystem]
    public class SendEventSystem : SystemBase
    {
        private bool isBooted;
	    private Sender cachedSender;
		private MessageSerializers messageSerializers;

        void BootUp()
        {
            var netSys = World.GetOrCreateSystem<NetworkSystem>();
			messageSerializers = new MessageSerializers(netSys.Mapper);
        }

	    protected override void OnUpdate()
	    {
	        if (!isBooted)
	        {
		        BootUp();
		        isBooted = true;
	        }

		    if (cachedSender == null)
		    {
			    cachedSender = World.GetExistingSystem<SyncSendSystem>().Sender;
			    if (cachedSender == null)
			    {
				    return;
			    }
            }

            var burstSender = cachedSender;
            var mapper = cachedSender.Mapper;



        }
    }

}


// ------------------ end of SendEvent.cs -----------------
#endregion



#region DeleteEvent
// -----------------------------------
//  DeleteEvent.cs
// -----------------------------------
			

namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Replication.Client.Unity.Ecs;
	using Unity.Entities;
	using Unity.Transforms;

	[AlwaysUpdateSystem]
	[UpdateInGroup(typeof(CoherenceSimulationSystemGroup))]
	[UpdateAfter(typeof(SyncSendSystem))]
	public class DeleteEventSystem : SystemBase
	{
		protected override void OnUpdate()
		{

			Dependency.Complete();
		}
	}
}
// ------------------ end of DeleteEvent.cs -----------------
#endregion



#region EventDeserializer
// -----------------------------------
//  EventDeserializer.cs
// -----------------------------------
			
namespace Coherence.Generated.Internal.FirstProject
{
	using global::Coherence.Generated.FirstProject;
	using Coherence.Log;
	using Unity.Entities;
	using Replication.Client.Unity.Ecs;
	using Coherence.Replication.Unity;

	public class PerformEvents : IPerformEvent
	{
        private MessageDeserializers messageDeserializers;

        public PerformEvents(UnityMapper mapper)
        {
            messageDeserializers = new MessageDeserializers(mapper);
        }

		public void PerformEvent(EntityManager mgr, Entity entity, uint eventTypeID,
                                 Coherence.Replication.Protocol.Definition.IInBitStream bitStream, ILog log)
		{

		}
	}
}


// ------------------ end of EventDeserializer.cs -----------------
#endregion
